{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":""},{"location":"#iden3-docs","title":"Iden3 Docs","text":"<p>Welcome to the documentation site of the Iden3 project, future-proof tech stack for self-sovereign identity.</p>"},{"location":"#iden3-on-github","title":"Iden3 on GitHub","text":""},{"location":"#versatility-of-applications","title":"Versatility of applications","text":"<p>The main idea of the iden3 protocol is that each identity is self-soverign and can issue claims on another identity (which can be for an individual, an organisation or a system/machine).</p> <p>This simple and unique characteristics can lead to creation complex adaptive systems and the following use cases:</p> <ul> <li>Decentralised trust models / web-of-trust</li> <li>Decentralised ID verification / proof-of-personhood</li> <li>Decentralised voting systems</li> <li>Interaction with DeFi / dApps / Web3</li> <li>Decentralised payment identifiers</li> <li>Private access control</li> <li>Authentication and authorisation</li> <li>Signing documents and private messaging</li> <li>Supply chain and IoT</li> <li>NFT ownership</li> </ul>"},{"location":"#iden3-protocol-libraries","title":"Iden3 protocol libraries","text":"<ul> <li> <p>Crypto library (go-iden3-crypto) Implementation of Poseidon hash and Baby JubJub Eliptic curve</p> </li> <li> <p>Merkle tree sql library (go-merkletree-sql) Implementation of Sparse Merkle tree</p> </li> <li> <p>Core library (go-iden3-core) Identity core primitives</p> </li> <li> <p>Circuits (circuits) Identity circuits</p> </li> <li> <p>Go-circuits (go-circuits) Library for transformation go-core primitives to json inputs for identity circuits</p> </li> <li> <p>Prover server (prover-server) Wrapper on snarkjs for ZK proof generation</p> </li> <li> <p>Authorization library (go-iden3-auth) Library for authentication with zkp verification (edited)</p> </li> </ul>"},{"location":"basics/getting-started/","title":"Getting Started","text":""},{"location":"basics/getting-started/#zero-knowledge-proofs","title":"Zero-knowledge Proofs","text":"<p>To learn how to create zero-knowledge proofs, have a look at Circom and SnarkJS guide.</p> <p>The process starts with employing various techniques of writing circuits for zero-knowledge proofs; it then moves on to creating and verifying a proof off-chain and finishes off by showing you how to replicate the process on-chain with Ethereum.</p>"},{"location":"basics/getting-started/#services-and-protocols","title":"Services and Protocols","text":"<p>To get started with any of our services/protocols, have a look here.</p>"},{"location":"basics/introduction/","title":"Introduction","text":"<p>Identity is a uniquely human concept. It is that ineffable \u201cI\u201d of self-consciousness, something that is understood worldwide by every person living in every culture. As Ren\u00e9 Descartes said, Cogito ergo sum \u2014 I think, therefore I am. (Source)</p> <p>What constitutes your identity? What makes you who you are? What is it about you that distinguishes you from others? Philosophers have argued over these questions since the beginning of civilization. Suffice to say there are no simple answers. Identity is a difficult concept to pin down.</p> <p>Nevertheless, we don't need a precise definition to see that there are problems with how modern society thinks about identity.</p> <p>In the words of Christopher Allen:</p> <p>Today, nations and corporations conflate driver\u2019s licenses, social security cards, and other state-issued credentials with identity; this is problematic because it suggests a person can lose his very identity if a state revokes his credentials or even if he just crosses state borders. I think, but I am not.</p> <p>How can we improve on this?</p> <p>It is clear that we are at an inflection point for how the digital world interacts with the physical world.</p> <p>The legacy systems of the physical world have not kept up with the rising importance of the digital world. As both worlds continue to merge, this scenario will need to change.</p> <p>This gives us an opportunity to create systems -- from the ground up -- that bridge the two. The systems that operate with a different concept of identity.</p> <p>If we design them well, these systems will allow us to redefine how modern society thinks about identity. Perhaps getting us closer to that ineffable \"I\" of self-consciousness.</p> <p>At Iden3, we're focused on building the tools and developing the protocols to make this happen.</p>"},{"location":"basics/key-concepts/","title":"Key Concepts","text":""},{"location":"basics/key-concepts/#identity","title":"Identity","text":"<p>At Iden3, our goal is to democratize identity. We believe that everyone should be empowered to become their own certification authority.</p> <p>What Do We Mean by Identity?</p> <p>An identity can be a person, a company, an organization, a DAO, or a government. Identity can even be a thing: a chair, a room, a bot, and so on. When we talk about identities, we are referring to \"identities as accounts\".</p> <p>Generally speaking, these accounts are going to be smart contracts. So you can think of identities as smart contracts, where the address of the contract is the identifier of that identity.</p> <p>Key Takeaways:</p> <ul> <li> <p>Anything can be an identity.</p> </li> <li> <p>One person can define and have many identities.</p> </li> <li> <p>In Ethereum, an identity is an account or a smart contract.</p> </li> </ul>"},{"location":"basics/key-concepts/#claims","title":"Claims","text":"<p>An identity  can provide a claim. You can think of a claim as a statement: something an identity is saying.</p> <p>Most of the time, these statements refer to other identities. In other words, claims usually create relations between identities.</p> <p>For example, when a university (identity) says that a student (identity) has a degree, this is a statement (claim) about the student. This statement creates a relation between the student and the university.</p> <p>Claims can be public or private. And it turns out that almost anything we say or do can be thought of as a claim. Company invoices, Facebook likes, and email messages can all be thought of as claims.</p>"},{"location":"basics/key-concepts/#examples-of-claims","title":"Examples of Claims","text":"<ul> <li> <p>A certificate (e.g. birth certificate)</p> </li> <li> <p>A debt recognition</p> </li> <li> <p>An invoice</p> </li> <li> <p>An Instagram \"Like\"</p> </li> <li> <p>An endorsement (reputation)</p> </li> <li> <p>An email</p> </li> <li> <p>A driving license</p> </li> <li> <p>A role in a company</p> </li> <li> <p>... Almost anything!</p> </li> </ul>"},{"location":"basics/key-concepts/#zero-knowledge-proofs","title":"Zero-knowledge Proofs","text":"<p>In cryptography, a zero-knowledge proof or zero-knowledge protocol is a method by which one party (the prover) can prove to another party (the verifier) that they know a value x, without conveying any information apart from the fact that they know the value x. (Source)</p> <p>In other words, zero-knowledge proofs allow us to prove something specific without revealing any extra information.</p> <p>Why do we care? Simply put, when we're talking about claims, sometimes, we want to prove things in a private manner.</p>"},{"location":"basics/key-concepts/#examples","title":"Examples","text":""},{"location":"basics/key-concepts/#nightclub-entry","title":"Nightclub Entry","text":"<p>Say you want to enter a nightclub, and you need to prove to the bouncer that you are over 18. But you don't want to reveal to him your name, address, or anything else that's not relevant.</p> <p>With zero-knowledge proof, you can prove that you hold the key that belongs to an identity that the state says is over 18, without revealing anything else about that identity.</p>"},{"location":"basics/key-concepts/#ico-participation","title":"ICO Participation","text":"<p>Say an ICO is available only to KYC-approved or authorized users. With ZK proofs, you can prove that you are an authorized person to participate in the ICO without revealing who you are or how much you spent.</p>"},{"location":"basics/key-concepts/#anonymous-voting","title":"Anonymous Voting","text":"<p>Similar to the above, ZK proofs allow you to prove that you are an eligible identity, without revealing your identity.</p>"},{"location":"basics/key-concepts/#non-reusable-proofs","title":"Non-reusable Proofs","text":"<p>A non-reusable proof is a received proof that is not valid to be sent to a third identity.</p> <p>For example, imagine that you belong to a given political party. This party has made a private claim that you belong to it.</p> <p>Now, you want to prove to another identity that you belong to the party, but you don't want that this identity to pass on that proof to others. In other words, you want to make sure the proof stays between the two of you.We can do this using zero-knowledge proofs.</p> <p>How?</p> <p>To prove something - let's call it A - we can create a new proof called B that is valid either if A is valid or we know the private key of the recipient, R.</p> <p>Clearly, we don't know R's private key, so when we share a valid proof B with R, R knows that A must be valid.</p> <p>To see why B is non-reusable, let us suppose that R wants to share B with another recipient R'.</p> <p>Now, from the perspective of R', B is valid either if A is valid or R knows its own private key.</p> <p>But since R clearly knows its private key, R' can't tell whether A is valid or not.</p>"},{"location":"basics/key-concepts/#zk-snarks","title":"ZK-SNARKs","text":"<p>You can think of ZK-SNARKs as an efficient way to produce zero-knowledge proofs. These are the proofs that are short enough to be published on blockchain and that can be read later by a verifier.</p>"},{"location":"basics/key-concepts/#digital-signatures","title":"Digital Signatures","text":"<p>A digital signature is a mathematical scheme for demonstrating the authenticity of digital messages or documents. A valid digital signature gives a recipient reason to believe that the message was created by a known sender, that the sender cannot deny having sent the message (authentication and non-repudiation), and that the message was not altered in transit (integrity). (Source)</p> <p>We use digital signatures for user authentication purposes and to prove that a claim was issued by a specific identity.</p>"},{"location":"basics/key-concepts/#merkle-trees","title":"Merkle Trees","text":"<p>In cryptography and computer science, a Merkle tree is a tree in which every leaf node is labeled with the hash of a data block and every non-leaf node is labeled with the cryptographic hash of the labels of its child nodes. (Source)</p> <p>We care about Merkle trees because we want to build a data structure that:</p> <ul> <li>Can store lots of data (scalability)</li> <li>Makes it easy to prove that some data exists (proof of membership)</li> <li>Allows us to check that the data hasn't been altered (tamper resistance)</li> </ul> <p>Merkle trees satisfy the three properties mentioned above.</p>"},{"location":"basics/key-concepts/#specifications","title":"Specifications","text":"<p>Before we take a closer look at these properties, let's go through how to build a Merkle tree with some given data.</p> <p></p> <p>Suppose we have several blocks containing data and that these blocks form the leaves of our tree. The first step is to create a parent node for each data block. These parent nodes form the next level in the tree and store the hash of their descendent data block.</p> <p></p> <p>Next, we group these parent nodes into pairs and store the hash of each pair one level up the tree.</p> <p></p> <p>We continue doing this until we are left with a single block, the root of the tree, also called Merkle Root.</p> <p></p>"},{"location":"basics/key-concepts/#tamper-resistance","title":"Tamper Resistance","text":"<p>It turns out that any attempt to tamper with any piece of data can be detected by simply remembering the hash at the root of the tree.</p> <p>To understand why this is the case, let\u2019s look at what happens if an adversary wants to tamper with a data block.</p> <p></p> <p>If an adversary tampers with a block at the leaf of our tree,</p> <p></p> <p>it will cause the mismatch with the hash in the node that\u2019s one level up.</p> <p></p> <p>So the adversary will have to tamper with that too.</p> <p></p> <p>This means s/he has to tamper with the node one level up from there.</p> <p></p> <p>And so on\u2026 Eventually, s/he will get to the root. If s/he tries to tamper with the root too, we\u2019ll know because this is the node we\u2019ve kept track of.</p>"},{"location":"basics/key-concepts/#proof-of-membership","title":"Proof of Membership","text":"<p>Merkle trees allow us to quickly check membership (through a neat mechanism known as Merkle proofs). What do we mean by that?</p> <p></p> <p>Suppose that, as usual, we remember just the root (on-chain). And we want to prove that a certain data block,\u200adata0,\u200ais a member of the Merkle tree.</p> <p></p> <p>All we need are the blocks on the path from the data block to the root.</p> <p></p> <p>And each of data0's siblings on the way up.</p> <p></p> <p>We can ignore the rest of the tree, as these blocks are enough to allow us to verify the hashes all the way up to the root of the tree. But how?</p> <p></p> <p>The idea is to recalculate the root by recursively hashing the data. If the calculated root is equal to the on-chain root, it proves that the data block exists in the Merkle tree.</p> <p></p> <p>In our case, we start by calculating the hash of data0 and storing it in the block labeled 0.</p> <p></p> <p>We then calculate the hash of the hash of data0 concatenated with the hash of data1. In other words, we calculate the hash of the concatenation of blocks 0 and 1\u200aand store it in block 4.</p> <p></p> <p>Finally, we calculate the hash of blocks 4 and 5 to obtain the recalculated root.</p> <p></p> <p>If the calculated root is equal to the on-chain root, we\u2019ve proven that data0 exists in the Merkle tree.</p> <p>In technical terms:</p> <p>This means that if there are n nodes in the tree, only about log(n) items need to be shown. And since each step just requires computing the hash of the child block, it takes about log(n) time for us to verify it. And so even if the Merkle tree contains a very large number of blocks, we can still prove membership in a relatively short time. Verification thus runs in time and space that\u2019s logarithmic in the number of nodes in the tree. (Source (pg 35))</p>"},{"location":"basics/key-concepts/#scalability","title":"Scalability","text":"<p>Storing data on a blockchain is expensive. Merkle trees help us in minimizing the amount of data stored on-chain. How?</p> <p>As we saw in the previous sections, to ensure tamper-resistance and Proof of Membership, we need to store only the root of the tree, not the whole tree. This means that no matter how big the tree is, the only piece of data we actually need to store on-chain is the root.</p>"},{"location":"basics/key-concepts/#sparse-merkle-trees","title":"Sparse Merkle Trees","text":"<p>At Iden3, we use a slightly more complex data structure called a sparse Merkle tree. </p> <p>A sparse Merkle tree is like a standard Merkle tree, except that its contained data is indexed, and each data block is placed at the leaf that corresponds to that block's index.</p> <p>In addition to inheriting the tamper-resistance and proof of membership properties from normal Merkle trees, sparse Merkle trees make it easy to prove that some data doesn\u2019t exist (proof of non-membership).</p>"},{"location":"basics/key-concepts/#proof-of-non-membership","title":"Proof of Non-membership","text":"<p>Now consider that we only have two pieces of data -- <code>data0</code> and <code>data3</code> -- with indices <code>0</code> and <code>3</code> respectively.  To construct a sparse Merkle tree, we populate the 0th and 3rd leaves with this data, leaving the 1st and 2nd leaves empty.</p> <p></p> <p>Well, almost empty! To be precise, we fill the 1st and 2nd leaves in with a special placeholder value like <code>null</code>.</p> <p></p> <p>With this placeholder, we can now build up the rest of the tree.</p> <p></p> <p>Now, what happens if we want to prove that a piece of (indexed) data -- <code>data2</code> -- is not a member of this tree?</p> <p></p> <p>Thanks to the way our data is indexed, proving that <code>data2</code> is not a member of the tree is equivalent to proving that the value of the leaf at index <code>2</code> is <code>null</code>!</p> <p>Put another way, proving non-membership of a <code>data</code> block is equivalent to proving membership of <code>null</code> (a simple Merkle proof). And as we saw in our previous post, doing this efficiently is a basic property of a Merkle tree.</p>"},{"location":"basics/key-concepts/#summary","title":"Summary","text":"<p>By indexing data and making leaves empty, sparse Merkle trees allow us to reframe proofs of non-membership into proofs of membership (a.k.a Merkle proofs), making it easy to prove that some data does not exist.</p> <p>One drawback to sparse Merkle trees is that they are really big. This means that without optimizations, read and write operations can be quite inefficient.</p> <p>For example, a sparse Merkle tree usually has 2^256 leaves vs. 2^32 for a normal Merkle tree. This means that naive implementations require 256 operations to read or write (vs 32).</p> <p>Luckily, these sorts of inefficiencies are largely illusory. Since fairly simple optimizations exist to get around them!</p> <p>Note</p> <p>While we won't get into the details here, one of the keys to these optimizations is that sparse Merkle trees are mostly sparse. This means many of the subtrees will end up being zero subtrees. </p> <p>Since H(0), H(H(0)), H(H(H(0))), and so on are all constant values, the zero-subtrees can be cached (calculated once, stored, and then omitted from Merkle proofs), greatly reducing the size of computations.</p>"},{"location":"basics/key-concepts/#why-do-we-use-merkle-trees-at-iden3","title":"Why Do We use Merkle Trees at Iden3?","text":"<p>At Iden3, one of our major goals is scalability. Specifically, we believe that anybody should be able to create as many identities as they want. And that any identity should be able to generate as many claims as it wants.</p> <p>Imagine if you had to make a new transaction to the blockchain every time you wanted to make a new claim? Even worse, imagine you're a government institution and you're responsible for making millions of claims every day.</p> <p>Achieving this goal requires minimizing the amount of data stored on-chain. This is where Merkle trees come into the picture.</p> <p>Even if you're a government institution that is making millions of claims a day, you can just construct a tree (off-chain) with each claim as a separate data block, and simply calculate and store the root on-chain.</p> <p>In other words, Merkle trees allow prolific claim generators to add/modify millions of claims in a single transaction. This makes it easy to scale the claims.</p>"},{"location":"basics/key-concepts/#definitions","title":"Definitions","text":""},{"location":"basics/key-concepts/#hash-functions","title":"Hash Functions","text":"<p>A hash function maps an input string of any size to an output string of a fixed size.</p> <p>It must be efficiently computable (for any given input string, we can figure out the output of the hash function in a reasonable amount of time. More technically, computing the hash of an n\u2010bit string should have a running time that is O(n)).</p> <p>For a hash function to be cryptographically secure, it must have three additional properties: </p> <ul> <li>Collision Resistance</li> <li>Hiding</li> <li>Puzzle-friendliness</li> </ul> <p>While we would not get into the details here, let's briefly discuss what each of these properties stands for.</p> <p>Collision Resistance means that nobody can find two inputs that map to the same output.</p> <p>Hiding means that given an output there's no feasible way to figure out the input that generated it.</p> <p>Puzzle-friendliness, intuitively, means that it is very hard to target the hash function to come out to some particular output value y. </p>"},{"location":"basics/key-concepts/#hash-pointers","title":"Hash Pointers","text":"<p>A hash pointer is simply a pointer to where some information is stored together with a cryptographic hash of the information. A pointer gives you a way to retrieve the information, whereas a hash pointer gives you a way to verify that the information wasn't changed.</p> <p>In other words, a hash pointer is a pointer to where data is stored along with a cryptographic hash of the value of that data at some fixed point in time.</p> <p>If at some point in the future, we want to check if the data hasn't changed, we simply hash the data again and verify that the new output (cryptographic hash) matches the previous output. This works because we know by the collision resistance property of the hash function that nobody can find two inputs that map to the same output. So if the output is the same, the input must also have been the same.</p>"},{"location":"basics/more-on-identity/","title":"More on Decentralized Identity","text":""},{"location":"basics/more-on-identity/#why-does-identity-matter","title":"Why Does Identity Matter?","text":"<p>In the words of Vitalik:</p> <p>Mechanisms that do not rely on identity cannot solve the problem of concentrated interests outcompeting dispersed communities; an identity-free mechanism that empowers distributed communities cannot avoid over-empowering centralized plutocrats pretending to be distributed communities.</p> <p>In other words, without an identity mechanism, one can't ensure \"one human, one address\" or \"one human, one vote\". This means that however you structure the rules of the system, those with the most resources would be able to game it.</p>"},{"location":"basics/more-on-identity/#how-is-the-existing-system-failing-us","title":"How Is the Existing System Failing Us?","text":"<p>In recent times, identities have been verified by credentials such as a passport or a social network account issued by a central authority (usually a state or corporation).</p> <p>However, as noted in Verifying Identity as a Social Intersection, such identity systems have several interrelated flaws:</p> <ol> <li> <p>They are insecure. Crucial data such as an ID number constantly has to be given out. This is enough to impersonate an individual. On top of this, since all data is stored in a single repository managed by the state or a corporation, it becomes particularly vulnerable to hacking or internal corruption.</p> </li> <li> <p>They narrow you down to one thing (in the system or out, a criminal or not, a credit score, etc.). The central database has little use for more information than this. This limits the functionality of the system and results in great injustices (for example, convicted individuals find it hard to re-enter society as this is the only information about them that they can reliably convey).</p> </li> <li> <p>They are artificial in the sense that the information stored about you usually bears little relation to what you or your friends think of you about your identity.</p> </li> </ol> <p>To quote directly from the paper:</p> <p>Recently, new identity paradigms have tried to get around some of these elements. One approach, adopted by \"big data\" platforms like Facebook and Google, is to overcome thinness [narrowness] by storing enormous amounts of detailed information about each individual. we might call this \"panoptic identity\". However, such solutions have greatly exacerbated the other two problems, as they require extremely artificial compromises to intimacy through the global sharing of data with platforms that would not otherwise store it, creating exceptional potential security risks.</p>"},{"location":"basics/more-on-identity/#why-do-we-need-this-vision-now","title":"Why Do We Need This Vision Now?","text":"<p>Given the rising political polarization and the increasing amount of information collected, shared, and cross-correlated by governments and corporations, there's a real risk that our information will be used against us in ways we cannot imagine.</p> <p>If history has taught us anything, it's that power belongs to those who control the information.</p> <p>Right now, that power belongs to the gatekeepers of our identities: governments and corporations.</p> <p>In an increasingly uncertain world, there's a real risk that general fear, discontent and polarization will result in that power being abused.</p> <p>In such a world, a check on the government and corporate power that goes beyond formal legal protection is essential.</p> <p>By putting the control of information back in our hands, decentralized identity systems provide a natural technological check on the ability of the governments and corporations to abuse their power.</p>"},{"location":"basics/more-on-identity/#how-can-the-developing-world-benefit","title":"How Can the Developing World Benefit?","text":"<p>In the developing world, decentralized identity systems have the potential to help bring millions of people out of the clutches of poverty.</p> <p>To quote the words of Timothy Ruff:</p> <p>Most of us take for granted that we can prove things about ourselves, unaware that over a billion people cannot. Identity is a prerequisite to financial inclusion, and financial inclusion is a big part of solving poverty.</p>"},{"location":"basics/more-on-identity/#what-are-some-of-the-use-cases","title":"What Are Some of the Use Cases?","text":""},{"location":"basics/more-on-identity/#liquid-democracy","title":"Liquid Democracy","text":"<p>Imagine if you could vote every two weeks to express your political sentiments regarding interest rates.</p> <p>Imagine if you could have a direct say in any decision rather than relying on elected politicians to represent you. Imagine if those in power were held accountable in real-time rather than once every few years. This is the promise of liquid democracy. Liquid democracy exists somewhere in the sweet spot between direct and representative democracy.</p> <p>As with direct democracy, everyone has the opportunity to vote on every issue. However, unlike direct democracy, you also have the choice to delegate your vote to someone else. You can even choose to delegate your votes on different issues to different people.</p> <p>For example, on environmental issues, you might choose to delegate your vote to your favourite environmentalist. Whereas on issues concerning government debt and taxation you might choose your father.</p> <p>This ability to delegate is recursive. It means that if your father, in turn, chooses to delegate his vote on financial issues to his favourite economist, your vote will also be delegated to that economist.</p> <p>If you're unhappy with your father's decision, you can take that power away from him/her, and either vote yourself or re-delegate to someone you deem more trustworthy.</p> <p>Under such a system, those with the most delegations become our representatives. But unlike representative democracy, they are held accountable in real-time.</p> <p>A system like this addresses the uninformed voters' issue that a direct democracy creates by allowing these voters allot their votes to experts. It also addresses the corruption issues of representative democracy because citizens can rescind their vote from someone instantly, forcing delegates to vote in the best interest of their constituents. It is the best of both worlds that truly gives the power of influence to the voters. (Source)</p> <p>This sounds almost too good to be true. A fair, transparent, and corruption-free government! Why haven't we implemented this before?</p> <p>Since there is no central government under this form of democracy, we need to figure out how to allow citizens to vote in a secure, private, and decentralized way. It turns out this is a pretty hard problem to solve. It has actually been impossible to solve. Until now. This is the first time in our history that technology exists to turn this dream into reality. Of course, we're talking about public blockchains.</p> <p>Right now, we're in the experimentation phase. There are still some hard challenges that need to be overcome.</p> <p>The three main challenges revolve around scalability, privacy, and Sybil attacks.</p> <p>Scalability is important because we need millions of people to be able to use these systems.</p> <p>Privacy is important because it ensures voters can't be discriminated against for the decisions they make. It also makes it harder for them to be bribed/coerced into voting for something they don't believe in.</p> <p>But perhaps the hardest challenge is to ensure that one person is not able to vote multiple times (what's known in the jargon as a Sybil attack).</p> <p>The key to solving the last two challenges is a voting protocol that requires basic verification and reputation for each user whilst protecting their pseudonymous identity. In other words, a voting protocol with a built-in decentralized identity system.</p> <p>Put another way, decentralized identity is the big unlock that's needed to turn liquid democracy into a reality.</p> <p>P.S. It turns out that solving the privacy problem helps solve the scalability problem too, but we won't get into that here.</p>"},{"location":"circom-snarkjs/","title":"Circom 2.0","text":"<p>Circuit Compiler for ZK Proving Systems</p> <p>Circom is a novel domain-specific language for defining arithmetic circuits and its associated compiler written in Rust language.</p> <p>Our open-source library of templates called CircomLib is publicly available to practitioners and developers. The library contains multiple circuit templates that have been reviewed and proven to work by our research team.</p> <p>The implementations of the proving systems are also available in our libraries: SnarkJS, written in Javascript and Pure Web Assembly; and rapidsnark written in C++ and has assembly optimizations for x86_64 and ARM processors.</p> <p>This way, Circom aims to provide developers with a holistic framework to construct arithmetic circuits through an easy-to-use interface and abstract the complexity of the proving mechanisms.</p>"},{"location":"circom-snarkjs/#circom","title":"==&gt; circom","text":""},{"location":"contracts/contracts/","title":"Contracts","text":"<p>State.sol - Github</p> <p>The State Contract stores the Global Identity State Tree. The GIST State represents a snapshot of the states of all the identities operating in the system. The design of the State Contract allows identities to authenticate themselves using Identity Profiles</p> <p>Every time that an identity is updated, for example when a credential is issued using SMT Proof or revoked, it needs to perform a State Transition. This process consists of generating a zk-proof or a digitally signed message that proves that the identity is authorized to perform the state transition. Then State contract verifies the proof on-chain via its transitState (for zk-proofs) or transitStateGeneric (generic as name suggests) function. Note that the actual zk-proof verification is performed by calling the <code>verifyProof</code> function inside the verifier.sol from the <code>transitState</code> function inside the State Contract.</p> <p>Whenever an identity is updated, the State contract updates the corresponding leaf of the GIST Tree. This process is managed by the SMTLib which is a Sparse Merkle Tree implementation that manages the GIST Tree and keeps track of its history.</p> <p>The <code>verifier.sol</code> contract is automatically generated using circom and can be used as a standalone contract to verify state transition zk-proof. <code>State</code> implements further logic once the proof is verified (such as updating the GIST State).</p>"},{"location":"contracts/contracts/#state-contract-addresses","title":"State contract addresses","text":"<ul> <li>Ethereum: 0x3C9acB2205Aa72A05F6D77d708b5Cf85FCa3a896</li> <li>Ethereum Sepolia: 0x3C9acB2205Aa72A05F6D77d708b5Cf85FCa3a896</li> <li>Polygon Mainnet: 0x624ce98D2d27b20b8f8d521723Df8fC4db71D79D</li> <li>Polygon Amoy Testnet: 0x1a4cC30f2aA0377b0c3bc9848766D90cb4404124</li> <li>Polygon zkEVM: 0x3C9acB2205Aa72A05F6D77d708b5Cf85FCa3a896</li> <li>Polygon zkEVM Cardona: 0x3C9acB2205Aa72A05F6D77d708b5Cf85FCa3a896</li> <li>Linea: 0x3C9acB2205Aa72A05F6D77d708b5Cf85FCa3a896</li> <li>Linea-Sepolia: 0x3C9acB2205Aa72A05F6D77d708b5Cf85FCa3a89</li> </ul> <p> IdentityTreeStore.sol - Github</p> <p>The identity tree store contract is responsible for storing revocation and roots tree nodes of Identity. In case when identity is using onchain RHS and Iden3OnchainSparseMerkleTreeProof2023 credential status.</p>"},{"location":"contracts/contracts/#identitytreestore-contract-addresses-on-chain-rhs","title":"IdentityTreeStore contract addresses (On-chain RHS)","text":"<ul> <li>Ethereum: 0x7dF78ED37d0B39Ffb6d4D527Bb1865Bf85B60f81</li> <li>Ethereum Sepolia: 0x7dF78ED37d0B39Ffb6d4D527Bb1865Bf85B60f81</li> <li>Polygon Mainnet: 0x7dF78ED37d0B39Ffb6d4D527Bb1865Bf85B60f81</li> <li>Polygon Amoy Testnet: 0x7dF78ED37d0B39Ffb6d4D527Bb1865Bf85B60f81</li> <li>Polygon zkEVM: 0x7dF78ED37d0B39Ffb6d4D527Bb1865Bf85B60f81</li> <li>Polygon zkEVM Cardona: 0x7dF78ED37d0B39Ffb6d4D527Bb1865Bf85B60f81</li> <li>Linea: 0x7dF78ED37d0B39Ffb6d4D527Bb1865Bf85B60f81</li> <li>Linea-Sepolia: 0x7dF78ED37d0B39Ffb6d4D527Bb1865Bf85B60f81</li> </ul>"},{"location":"contracts/contracts/#validator_mtp_v2-contract-addresses","title":"VALIDATOR_MTP_V2 contract addresses","text":"<ul> <li>Ethereum: 0x27bDFFCeC5478a648f89764E22fE415486A42Ede</li> <li>Ethereum Sepolia: 0x27bDFFCeC5478a648f89764E22fE415486A42Ede</li> <li>Polygon Mainnet: 0x27bDFFCeC5478a648f89764E22fE415486A42Ede</li> <li>Polygon Amoy Testnet: 0x27bDFFCeC5478a648f89764E22fE415486A42Ede</li> <li>Polygon zkEVM: 0x27bDFFCeC5478a648f89764E22fE415486A42Ede</li> <li>Polygon zkEVM Cardona: 0x27bDFFCeC5478a648f89764E22fE415486A42Ede</li> <li>Linea: 0x27bDFFCeC5478a648f89764E22fE415486A42Ede</li> <li>Linea-Sepolia: 0x27bDFFCeC5478a648f89764E22fE415486A42Ede</li> </ul>"},{"location":"contracts/contracts/#validator_sig_v2-contract-addresses","title":"VALIDATOR_SIG_V2 contract addresses","text":"<ul> <li>Ethereum: 0x59B347f0D3dd4B98cc2E056Ee6C53ABF14F8581b</li> <li>Ethereum Sepolia: 0x59B347f0D3dd4B98cc2E056Ee6C53ABF14F8581b</li> <li>Polygon Mainnet: 0x59B347f0D3dd4B98cc2E056Ee6C53ABF14F8581b</li> <li>Polygon Amoy Testnet: 0x59B347f0D3dd4B98cc2E056Ee6C53ABF14F8581b</li> <li>Polygon zkEVM: 0x59B347f0D3dd4B98cc2E056Ee6C53ABF14F8581b</li> <li>Polygon zkEVM Cardona: 0x59B347f0D3dd4B98cc2E056Ee6C53ABF14F8581b</li> <li>Linea: 0x59B347f0D3dd4B98cc2E056Ee6C53ABF14F8581b</li> <li>Linea-Sepolia: 0x59B347f0D3dd4B98cc2E056Ee6C53ABF14F8581b</li> </ul>"},{"location":"contracts/contracts/#validator_v3-contract-addresses","title":"VALIDATOR_V3 contract addresses","text":"<ul> <li>Ethereum: 0xd179f29d00Cd0E8978eb6eB847CaCF9E2A956336</li> <li>Ethereum Sepolia: 0xd179f29d00Cd0E8978eb6eB847CaCF9E2A956336</li> <li>Polygon Mainnet: 0xd179f29d00Cd0E8978eb6eB847CaCF9E2A956336</li> <li>Polygon Amoy Testnet: 0xd179f29d00Cd0E8978eb6eB847CaCF9E2A956336</li> <li>Polygon zkEVM: 0xd179f29d00Cd0E8978eb6eB847CaCF9E2A956336</li> <li>Polygon zkEVM Cardona: 0xd179f29d00Cd0E8978eb6eB847CaCF9E2A956336</li> <li>Linea: 0xd179f29d00Cd0E8978eb6eB847CaCF9E2A956336</li> <li>Linea-Sepolia: 0xd179f29d00Cd0E8978eb6eB847CaCF9E2A956336</li> </ul>"},{"location":"getting-started/babyjubjub/","title":"Baby Jubjub Key Pair","text":"<p>In Iden3 Protocol the public and private key pair is used to manage an identity and to authenticate in the name of an identity. In particular, Baby Jubjub is the elliptic curve used in Iden3. This curve is designed to work efficiently with zkSNARKs.</p> <p>1.Initiate a Go Module</p> <pre><code>go mod init example/iden3-tutorial\n</code></pre> <p>2.Update the required dependencies.</p> <pre><code>go get github.com/iden3/go-iden3-crypto/babyjub\n</code></pre> <p>3.Generate a baby jubjub public key.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"github.com/iden3/go-iden3-crypto/babyjub\"\n)\n\n// BabyJubJub key\nfunc main() {\n\n    // generate babyJubjub private key randomly\n    babyJubjubPrivKey := babyjub.NewRandPrivKey()\n\n    // generate public key from private key\n    babyJubjubPubKey := babyJubjubPrivKey.Public()\n\n    // print public key\n    fmt.Println(babyJubjubPubKey)\n}\n</code></pre> <p>Here is an example of a public key generated using Baby Jubjub:</p> <pre><code>500d43e1c3daa864995a9615b6f9e3a4fd0af018548c583773b6e422b14201a3\n</code></pre> <p>The executable code can be found here</p>"},{"location":"getting-started/claim-revocation/","title":"Revocation","text":"<p>Revocation is the process of invalidating a claim. For example, if a claim is used to prove that a person is resident in a country, and the person moves to another country, the claim can be revoked by the issuer.</p> <p>This is done by adding the claim revocation nonce to the revocation tree. The revocation tree contains revocation nonces of all the claims that were revoked. The root of the revocation tree is stored in the identity state.</p> <p>To revoke a claim, the revocation nonce of the claim must be added to the revocation tree. The revocation nonce is a number that is added to the claim data structure when it is created. </p> <pre><code>    // revocation nonce of the claim to be revoked\n    revocationNonce := uint64(1909830690)\n\n    // add the revocation nonce to the revocation tree\n    ret.Add(ctx, new(big.Int).SetUint64(revNonce), big.NewInt(0))\n</code></pre> <p>The action of adding the revocation nonce to the revocation tree modifies the root of the revocation tree and, consequently, the identity state. </p> <p>To finalize the revocation process, the identity state must be updated on-chain by executing a state transition.</p>"},{"location":"getting-started/getting-started/","title":"Introduction","text":"<p>The first part of the tutorial walks you through the core components of Iden3 protocol necessary to initiate an identity and design claims:</p> <ul> <li>Baby Jubjub Keypair</li> <li>Sparse Merkle Tree </li> <li>Claim</li> <li>Identity</li> </ul> <p>Having understood the primitives you will be then able to start issuing claims.</p> <p>The tutorial follows a cascade strucuture: each step relies on the data and code snippets generated in the previous ones. The full executable code can be found here</p>"},{"location":"getting-started/getting-started/#iden3-go-core-libraries","title":"Iden3 Go Core Libraries","text":"<ul> <li>Go Iden3 core - Identity core primitives</li> <li>Go Iden3 crypto - Implementation of Poseidon hash and Baby JubJub Elliptic curve</li> <li>Go Merkletree sql - Implementation of Sparse Merkle tree</li> <li>Go circuits - A library for transforming the go-core primitives to json inputs for identity circuits</li> </ul>"},{"location":"getting-started/getting-started/#other-useful-resources","title":"Other useful resources","text":"<ul> <li>Circom2 - A compiler written in Rust for compiling circuits written in the Circom language</li> <li>SnarkJS - An npm package that contains APIs to generate and validate zk proofs generated by Circom</li> <li>GoLang Intro - Recommended if you are not proficient with GoLang</li> </ul>"},{"location":"getting-started/issue-claim-overview/","title":"Overview","text":"<p>In the last section, you have initiated an identity and created different types of claims. As of now, the claims haven\u2019t been published or issued in any way. The goal of this section is to issue claims so that the receiver can start using them within other applications. </p> <p>Starting from the same core claim there are two ways of issuing it: via Signature or via Merkle tree.</p>"},{"location":"getting-started/issue-claim-overview/#via-signature","title":"Via Signature","text":"<p>The claim gets signed by the issuer using her private key. The proof of issuance is the signature itself. This action doesn\u2019t modify the identity state of the issuer, so there\u2019s no on-chain transaction involved.</p>"},{"location":"getting-started/issue-claim-overview/#via-merkle-tree","title":"Via Merkle tree","text":"<p>The claim gets added to the issuer\u2019s Claims Tree. This action modifies the structure of the Merkle Tree and, therefore, the state has to be updated with the new Merkle root. The state transition involves an on-chain transaction. In this case, the proof of issuance is the membership of the claim itself inside the issuer\u2019s Claims Tree.</p>"},{"location":"getting-started/issue-claim-overview/#similarities-and-differences","title":"Similarities and Differences","text":"<p>Both approaches guarantee that the claim is tamper-resistant. The private zk-based verification of the claim is equally guaranteed in both cases.</p> <p>The process of updating the on-chain state (in the case of Merkle Tree (MT)) may take around 10/20 seconds, so the claim could not be immediately available to use for the user. Instead, with Signature (S), the claim is immediately ready for use. The biggest advantage of MT approach is that it offers timestamp proof of an identity state: a user could always prove the existence of a claim at a specific point in time according to the block number when it was added to the issuer tree. Naturally, this comes at a cost: the gas fees needed to update the state (458,228 gas used inside the transaction). No on-chain transactions take place in the case of S.  A further element of difference regards the uniqueness of the claim: in the MT case, there couldn\u2019t be two claims with the same index Claim Data Structure. This is guaranteed by the characteristic of Sparse Merkle Tree. With S, an issuer could sign as many claims they want with the same index. Let\u2019s consider an example: a passport issued as a claim. This claim contains the identifier of the passport owner inside its index. MT approach provides a cryptographic guarantee that the issuer cannot duplicate the passport by issuing a claim with the same identifier. S doesn\u2019t.</p> <p>Note: This section describes the claim issuance on a protocol level. The way in which issuers and users\u2019 wallets communicate and transfer claims is defined on a platform level. This will be the subject of Polygon ID light issuer tutorial coming out this Autumn. </p>"},{"location":"getting-started/json-ld-credential/","title":"W3C Verifiable Credentials","text":""},{"location":"getting-started/json-ld-credential/#json-ld-credential-and-claim","title":"JSON-LD Credential and Claim","text":"<p>A Claim is the core data structure used by Iden3 to represent information. A claim by itself doesn't contain enough meaningful information to be read, understood and consumed (e.g. by the wallet). For example, it doesn't tell anything about the meaning of values stored inside the data slots. </p> <p>The JSON-LD credential is able to pack the information contained in a claim in a more human-readable way. Furthermore, a JSON-LD credential does not only contain the claim itself but other proofs needed for the subject of the claim needs to consume the claim with other Verifiers.</p> <p>Let's anaylise what is a JSON-LD Credential with a practical example. The first tab contains a claim attesting to someone's date of birth (this is the same claim generated in the Generic Claim Section). The second tab contains the corresponding JSON-LD Credential of type <code>KYCAgeCredential</code>.</p> <p>=== \"Core Claim Format\"</p> <pre><code>```go\nIndex:\n{\n\"3613283249068442770038516118105710406958\", // Claim Schema hash\n\"86645363564555144061174553487309804257148595648980197130928167920533372928\", // ID Subject of the claim\n\"19960424\", // First index data slot stores the date of birth\n\"1\"  //  Second index data slot stores the document type\n}\n\nValue:\n{ \n\"227737944108667786680629310498\", // Revocation nonce \n\"0\",\n\"0\", // first value data slot\n\"0\"  // second value data slot\n}   \n```\n</code></pre> <p>=== \"JSON-LD Credential\"</p> <pre><code>``` json\n{\n    \"id\": \"eca80230-6ed1-4251-8fe9-3c0204ba10ba\",\n    \"@context\": [\n        \"https://raw.githubusercontent.com/iden3/claim-schema-vocab/main/schemas/json-ld/iden3credential.json-ld\",\n        \"https://raw.githubusercontent.com/iden3/claim-schema-vocab/main/schemas/json-ld/kyc-v2.json-ld\"\n    ],\n    \"@type\": [\n        \"Iden3Credential\"\n    ],\n    \"expiration\": \"2361-03-22T00:44:48+05:30\",\n    \"updatable\": false,\n    \"version\": 0,\n    \"rev_nonce\": 1909830690,\n    \"credentialSubject\": {\n        \"birthday\": 19960424,\n        \"documentType\": 1,\n        \"id\": \"113TCVw5KMeMp99Qdvub9Mssfz7krL9jWNvbdB7Fd2\",\n        \"type\": \"KYCAgeCredential\"\n    },\n    \"credentialStatus\": {\n        \"id\": \"https://fe03-49-248-235-75.in.ngrok.io/api/v1/claims/revocation/status/1909830690\",\n        \"type\": \"SparseMerkleTreeProof\"\n    },\n    \"subject_position\": \"index\",\n    \"credentialSchema\": {\n        \"@id\": \"https://raw.githubusercontent.com/iden3/claim-schema-vocab/main/schemas/json-ld/kyc-v2.json-ld\",\n        \"type\": \"KYCAgeCredential\"\n    },\n    \"proof\": [\n        {\n            \"@type\": \"BJJSignature2021\",\n            \"issuer_data\": {\n                \"id\": \"113TCVw5KMeMp99Qdvub9Mssfz7krL9jWNvbdB7Fd2\",\n                \"state\": {\n                    \"claims_tree_root\": \"ea5774fac8d72478d4db8a57a46193597bb61475fc9e72bdc74a0ce35aa85518\",\n                    \"value\": \"5ccc30d5d0360170a29188d5a907381098801a1ab09003493d9833fa4d95271f\"\n                },\n                \"auth_claim\": [\n                    \"304427537360709784173770334266246861770\",\n                    \"0\",\n                    \"6610201945487752676983171932113332232608162355365546060896064454271869708127\",\n                    \"11380100573862532536254569563965305187461805636461289256869908267462627351172\",\n                    \"0\",\n                    \"0\",\n                    \"0\",\n                    \"0\"\n                ],\n                \"mtp\": {\n                    \"existence\": true,\n                    \"siblings\": []\n                },\n                \"revocation_status\": \"https://fe03-49-248-235-75.in.ngrok.io/api/v1/claims/revocation/status/1909830690\"\n            },\n            \"signature\": \"5e1356754a061c9f691496a4b4bd4cab5d1d74eb835ef7575fc6b2c1e8b4311dab9e2b544f9c3f4701324b1e0b3a8c09de22425de9038c2a08f98f6963f17102\"\n        }\n    ]\n}\n```\n</code></pre> <p>The core claim (1st tab) contains a limited set of information such as the schema hash, the identity subject of the claim, the data slots stored inside the claim (in this case the date of birth) and the revocation nonce of the claim. It's worth noting that the claim by itself doesn't say anything about the meaning of this content. How can someone infer that that value refers to a birthday? Furthermore the claim doesn't reveal information about the issuer, nor whether it has been revoked or not. All these set of extended information about a claim are included in the JSON-LD format in order to allow other parties to consume and understand the content of a claim.</p> <p>In particular the first part of the JSON-LD Credential contains the details of the claim: </p> <ul> <li><code>id</code> namely the identifier of the credential itself</li> <li><code>context</code>, as per JSON-LD spec is used to establish a description of the common terms that we will be using such as \"expiration\", \"updatable\" .... In particular the first one is standard for iden3 credential vocabulary while the second is specific to this type of claim. </li> <li><code>type</code> defines the type of the credential itself, when dealing with iden3 claim the credential should always be named Iden3Credential</li> <li><code>expriation</code> which is a field contained in the claim in v_0(specifically, the hash of this value is contained in the claim)</li> <li><code>updatable</code> which is a field contained in the claim in i_0</li> <li><code>version</code> which is a field contained in the claim in i_0</li> <li><code>rev_nonce</code> which is a field contained in the claim in v_0 </li> <li><code>credentialSubject</code> which contains all the details about the subject of the claim and the information contained in the claim regarding the subject</li> <li><code>credentialStatus</code> which contains a url to fetch the revocation status of the claim </li> <li><code>subject_position</code> indicates whether the identifier of the subject of the claim should be stored inside index data slot (i_1) or value data slot (v_1)</li> <li><code>credentialSchema</code> defines the Schema of the claim itself</li> </ul> <p>The second part ofthe JSON-LD Credential contains a cryptographic proof that the credentials was issued by a specific issuer:</p> <ul> <li><code>@type</code> indicates the way the proof was generated. It can be either \"BJJSignature2021\" or \"Iden3SparseMerkleProof\"</li> <li><code>issuer_data</code> contains all the data related to the issuer of the claim. Including its identifier (<code>id</code>), its identity state value at the time of the issuance (<code>id</code>), its Auth Claim (<code>auth_claim</code>), the merkle tree proof that the Auth Claim belongs to the Claims Tree at the time of the issuance (<code>mtp</code>) and, lastly, a url to fetch the revocation status of the issuer's auth claim (<code>revocation_status</code>)</li> <li><code>signature</code> contains the signed claim generated using the issuer's private key</li> </ul> <p>In this case the claim was issued by signature, in the case of claim of Merkle Tree Type the proof array would also contain a second value, namely the <code>Iden3SparseMerkleProof</code> of inclusion of the issued claim inside the issuer's Claims Tree </p> <p>The subject of the claim will store the JSON-LD format credential inside their wallet. Starting from the details contained inside the Credential he/she will be able to generate zk proofs and present it to Verifiers.</p> <ul> <li>[] Why we need that JSON-LD Credential?</li> <li>[] How am I able to get from the credential to core-claim? Is it gonna match? Is it also able to parse revocation nonce etcetera? </li> <li>[] Does the parsing also work in reverse? From claim to VC?</li> <li>[] What is <code>signature</code>? -\u00a0[] Add part to explain how to parse the VC into a core claim</li> </ul>"},{"location":"getting-started/mt/","title":"Sparse Merkle Tree","text":"<p>A Merkle Tree or a hash tree is a cryptographically verifiable data structure where every \"leaf\" node of the tree contains the cryptographic hash of a data block, and every non-leaf node contains the cryptographic hash of its child nodes.</p> <p>The Merkle Trees used in Iden3 protocol are Sparse. In Sparse Merkle Trees each data block has an index associated to it that determines its position as leaf inside the tree. </p> <p>In addition to inheriting the tamper-resistance and proof-of-membership properties from standard merkle trees, a Sparse Merkle Tree has other features:</p> <ul> <li>The insert order of data blocks doesn't influence the final Merkle Tree Root. A data block <code>A</code> with index <code>1</code> and a data block <code>B</code> with index <code>4</code> will always occupy the same positions inside the tree despite the insert order</li> <li>Some leaves remain empty</li> <li>It's possible to prove that certain data is not included in the tree (proof of non-membership)</li> </ul> <p>A Sparse Merkle Tree is the core data structure used in Iden3 protocol to represent an identity. In particular, the leaves of a Sparse Merkle Tree are the claims issued by an identity. </p> <p>1.Update the required dependencies.</p> <pre><code>go get github.com/iden3/go-merkletree-sql \n</code></pre> <p>2.Design a Sparse Merkle Tree.</p> <pre><code>package main\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"math/big\"\n\n    merkletree \"github.com/iden3/go-merkletree-sql\"\n    \"github.com/iden3/go-merkletree-sql/db/memory\"\n)\n\n// Sparse MT\nfunc main() {\n\n    ctx := context.Background()\n\n    // Tree storage\n    store := memory.NewMemoryStorage()\n\n    // Generate a new MerkleTree with 32 levels\n    mt, _ := merkletree.NewMerkleTree(ctx, store, 32)\n\n    // Add a leaf to the tree with index 1 and value 10\n    index1 := big.NewInt(1)\n    value1 := big.NewInt(10)\n    mt.Add(ctx, index1, value1)\n\n    // Add another leaf to the tree\n    index2 := big.NewInt(2)\n    value2 := big.NewInt(15)\n    mt.Add(ctx, index2, value2)\n\n    // Proof of membership of a leaf with index 1\n    proofExist, value, _ := mt.GenerateProof(ctx, index1, mt.Root())\n\n    fmt.Println(\"Proof of membership:\", proofExist.Existence)\n    fmt.Println(\"Value corresponding to the queried index:\", value)\n\n    // Proof of non-membership of a leaf with index 4\n    proofNotExist, _, _ := mt.GenerateProof(ctx, big.NewInt(4), mt.Root())\n\n    fmt.Println(\"Proof of membership:\", proofNotExist.Existence)\n}\n</code></pre> <p>A data block inside the tree is represented by a <code>index</code> and a <code>value</code>. The index represents the position in the tree and it must be unique. The value represents the associated value stored in the tree.</p> <p>The <code>GenerateProof</code> method shown above allows verifying the membership of a leaf in the merkle tree starting from its root. </p> <p>The executable code can be found here</p>"},{"location":"getting-started/claim/auth-claim/","title":"Key Authorization Claim","text":"<p>The most important building block of an identity is the Key Authorization Claim. This claim stores user's Baby Jubjub public key. </p> <p>An Auth Claim must be included as a leaf inside the  Identity Tree. All the actions performed by an Idenitity (such as claim issuance or revocation) require users to prove via a digital signature that they own the private key associated with the public key stored in the <code>AuthClaim</code>.</p> <p>1.Specify the credential schema</p> <p>The auth claim schema is pre-defined and should always be the same when creating an <code>AuthClaim</code>. The schema hash is: <code>ca938857241db9451ea329256b9c06e5</code>. According to this schema, X and Y coordinates of the Baby Jubjub public key must be stored, respectively, in the first and second index data slot.</p> <p>2.Generate an AuthClaim. </p> <pre><code>package main\n\nimport (\n    \"encoding/json\"\n    \"fmt\"\n\n    \"github.com/iden3/go-iden3-core\"\n    \"github.com/iden3/go-iden3-crypto/babyjub\"\n)\n\n// Create auth claim\nfunc main() {\n\n    authSchemaHash, _ := core.NewSchemaHashFromHex(\"ca938857241db9451ea329256b9c06e5\")\n\n    // Add revocation nonce. Used to invalidate the claim. This may be a random number in the real implementation.\n    revNonce := uint64(1)\n\n    // Create auth Claim \n    authClaim, _ := core.NewClaim(authSchemaHash,\n    core.WithIndexDataInts(babyJubjubPubKey.X, babyJubjubPubKey.Y),\n    core.WithRevocationNonce(revNonce))\n\n    authClaimToMarshal, _ := json.Marshal(authClaim)\n\n    fmt.Println(string(authClaimToMarshal))\n}\n</code></pre> <p>Here is what the claim would look like: </p> <pre><code>Claim:\n[\"304427537360709784173770334266246861770\",\"0\",\"12360031355466667401641753955380306964012305931931806442343193949747916655340\",\"7208907202894542671711125895887320665787554014901011121180092863817137691080\",\"1\",\"0\",\"0\",\"0\"]\n</code></pre> <p>Let us destructure the output:</p> <pre><code>Index:\n{\n\"304427537360709784173770334266246861770\", // Schema hash\n\"0\",\n\"12360031355466667401641753955380306964012305931931806442343193949747916655340\",  // X coordinate of the pubkey     \n\"7208907202894542671711125895887320665787554014901011121180092863817137691080\"   // Y coordinate of the pubkey\n}\n\nValue:\n{ \n\"1\", // revocation nonce\n\"0\",\n\"0\", // first value data slot\n\"0\"  // second value data slot\n}   \n</code></pre> <p>The data stored in position 1 of the Value contains the Revocation Nonce. This value will be used to revoke/invalidate an <code>AuthClaim</code>. More on that in the next section.</p> <p>The executable code can be found here</p>"},{"location":"getting-started/claim/claim-schema/","title":"Credential Schema","text":"<p>The reusability of credentials across platforms and services is guaranteed by Credential Schema consistency. </p> <p>Polygon ID use JSON-LD documents to represent Credential Schemas.</p> <p>As an issuer it is advised to check if any of the existing credential schemas can accommodate the type of information you are interested to issue.</p> <p>If not, here's the guide to create a new credential schema. Let us create a shared and reusable credential schema of type ProofOfDaoMembership.</p> <p>1.Define the value to be included in the schema.</p> <p>The ProofOfDaoMembership credential should attest that a person executes a role inside a specific DAO.</p> <p>Information such as the identifier of the DAO or the identifier of the subject of the credential don't need to be encoded inside one of the four data slots allocated for claim information (i_2,i_3, v_2, v_3): </p> <ul> <li>The information about the specific DAO can be inferred from the credential issuer identifier</li> <li>The information about the individual subject of the claim is already stored in the i_1 or v_1 data slot of the Claim.</li> </ul> <p>A further information that must be included in the claim is the role of the individual inside a DAO. This will be the added inside one of the data slots (i_2,i_3,v_2,v_3). </p> <p>Remember that a claim can only store numeric data so each DAO role should be encoded as a number.</p> <p>2.Decide where to store this information, should it be inside index data slots or value data slots?</p> <p>Claim's index determines its uniqueness inside the issuer's claims tree. There cannot be more than one claim with the same index. If it is decided to store the identifier of the subject of the claim inside i_1 and leave the other index data slots empty, it means that there can only be one claim issued to a specific identity inside the tree.</p> <p>In this case, the question is whether to store the information with type role inside i_2 or v_2.</p> <ul> <li>Storing the role inside i_2 means that the uniqueness inside the tree is determined by the combination \"person identifier + role\"</li> <li>Storing the role inside v_2 means that the uniqueness inside the tree is only determined the person identifier</li> </ul> <p>Considering the possibility that a DAO member covers more than one role, it makes more sense to store the role inside i_2. This choice allow the DAO to issue subsequent claims to the same individual attesting a different role.</p> <p>3.Describe the vocabulary of the schema</p> <p>Create a markdown file in your repository to describe the vocabulary used in the claim. This should contain a description of the key type role and its possible values:</p> <pre><code># role\n\nDescribes the role covered by an individual inside a specific DAO\n\n1: Contributor\n2: Guild Coordinator\n3: Team Member\n</code></pre> <p>4.Create the JSON-LD document</p> <p>Add a file inside your repository with extension .json-ld and populate it.</p> <p>The <code>@id</code> key should contain the identifier of the Schema Type \"ProofOfDaoMembership\", in this case the unique url to the JSON-LD document. The <code>proof-of-dao-vocab</code> key should contain the url that describes the vocabulary of the claim schema.</p> <pre><code>{\n  \"@context\": [{\n    \"@version\": 1.1,\n    \"@protected\": true,\n    \"id\": \"@id\",\n    \"type\": \"@type\",\n    \"ProofOfDaoMembership\": {\n      \"@id\": \"https://raw.githubusercontent.com/iden3/tutorial-examples/main/claim-schema/proof-of-dao-membership.json-ld#ProofOfDaoMembership\",\n      \"@context\": {\n        \"@version\": 1.1,\n        \"@protected\": true,\n        \"id\": \"@id\",\n        \"type\": \"@type\",\n        \"proof-of-dao-vocab\": \"https://github.com/iden3/tutorial-examples/blob/main/claim-schema/proof-of-dao.md#\",\n        \"serialization\": \"https://github.com/iden3/claim-schema-vocab/blob/main/credentials/serialization.md#\",\n        \"type\": {\n          \"@id\": \"proof-of-dao-vocab:role\",\n          \"@type\": \"serialization:IndexDataSlotA\"\n        },\n      }\n    }\n  }]\n}\n</code></pre> <p>5.Generate the schema hash</p> <p>The Schema Hash has to be added inside claim's index.</p> <p>The schema hash is generated by hashing together <code>schemaBytes</code> (the JSON-LD document in byte format) and <code>credentialType</code> (in this case \"ProofOfDaoMembership\"). In this case:</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"os\"\n\n    core \"github.com/iden3/go-iden3-core\"\n    \"github.com/iden3/go-iden3-crypto/keccak256\"\n)\n\nfunc main() {\n\n  schemaBytes, _ := os.ReadFile(\"./tutorial-examples/claim-schema/proof-of-dao-membership.json-ld\")\n\n    var sHash core.SchemaHash\n    h := keccak256.Hash(schemaBytes, []byte(\"ProofOfDaoMembership\"))\n\n    copy(sHash[:], h[len(h)-16:])\n\n    sHashHex, _ := sHash.MarshalText()\n\n    fmt.Println(string(sHashHex))\n    // 4f6bbcb133bfd4e9ebdf09b16a0816c8\n}\n</code></pre> <p>The executable code can be found here</p>"},{"location":"getting-started/claim/generic-claim/","title":"Generic Claim","text":"<p>A Claim is a statement made by one identity about another identity or about itself. In general, claim is a flexible and modular data primitive that can be used to represent any identity-related information.</p> <p>Claims can be viewed as Soul Bound Tokens (SBTs) on steroids. Similar to SBTs, the ownership is cryptographically guaranteed allowing control and reusability across platforms. Differently to SBTs, claims live off-chain ensuring users privacy over their Personal Identifiable Information.</p> <p>1.Update the required dependencies.</p> <pre><code>go get github.com/iden3/go-iden3-core\n</code></pre> <p>2.Specify the credential schema.</p> <p>A credential schema defines how a set of data must be stored inside a claim. In this example, we will use a schema called <code>KYCAgeCredential</code>. According to this schema the birthday is stored in the first index slot of the claim data structure, while the documentType is stored in the second data slot.</p> <p>The hash of the schema is generated from the content of the schema document following the Claim Schema Generation Rules. For our example, the hash of the schema is: <code>2e2d1c11ad3e500de68d7ce16a0a559e</code></p> <p>3.Create a generic claim. </p> <pre><code>package main\n\nimport (\n    \"encoding/json\"\n    \"fmt\"\n    \"math/big\"\n    \"time\"\n\n    core \"github.com/iden3/go-iden3-core\"\n)\n\n// create basic claim\nfunc main() {\n\n    // set claim expriation date to 2361-03-22T00:44:48+05:30\n    t := time.Date(2361, 3, 22, 0, 44, 48, 0, time.UTC)\n\n    // set schema\n    ageSchema, _ := core.NewSchemaHashFromHex (\"2e2d1c11ad3e500de68d7ce16a0a559e\")  \n\n    // define data slots\n    birthday := big.NewInt(19960424)\n    documentType := big.NewInt(1)   \n\n    // set revocation nonce \n    revocationNonce := uint64(1909830690)\n\n    // set ID of the claim subject\n    id, _ := core.IDFromString(\"113TCVw5KMeMp99Qdvub9Mssfz7krL9jWNvbdB7Fd2\")\n\n    // create claim \n    claim, _ := core.NewClaim(ageSchema, core.WithExpirationDate(t), core.WithRevocationNonce(revocationNonce), core.WithIndexID(id), core.WithIndexDataInts(birthday, documentType))\n\n    // transform claim from bytes array to json \n    claimToMarshal, _ := json.Marshal(claim)\n\n    fmt.Println(string(claimToMarshal))\n}\n</code></pre> <p>Here is what the claim would look like: <pre><code>[\"3613283249068442770038516118105710406958\",\"86645363564555144061174553487309804257148595648980197130928167920533372928\",\"19960424\",\"1\",\"227737944108667786680629310498\",\"0\",\"0\",\"0\"]\n</code></pre></p> <p>In particular, the first 4 values of the claim represent the <code>Index</code> part of the claim while the last 4 represent the <code>Value</code>. <pre><code>Index:\n[\n    \"3613283249068442770038516118105710406958\", // Claim Schema hash\n    \"86645363564555144061174553487309804257148595648980197130928167920533372928\", // ID Subject of the claim\n    \"19960424\", // First index data slot stores the date of birth\n    \"1\"  //  Second index data slot stores the document type\n]\n\nValue:\n[ \n    \"227737944108667786680629310498\", // Revocation nonce \n    \"0\",\n    \"0\", // first value data slot\n    \"0\"  // second value data slot\n]   \n</code></pre></p> <p>The data stored in the first position of the Index contains a reference to the schemahash of the claim. As defined in the <code>KYCAgeCredential</code> schema, the value birthday must be stored in the first index data slot while the second index stores the documentType. Other schemas may provide different rules on where to store the data.</p> <p>The executable code can be found here</p>"},{"location":"getting-started/identity/identifier/","title":"Identifier","text":"<p>Each identity has one main identifier - Genesis ID, and can have many additional identifiers - Identity Profiles.</p> <p>Genesis ID is:</p> <ul> <li>Permanent: it remains the same for the entire existence of an identity.</li> <li>Unique: No two identities can have the same ID.</li> </ul> <p>The Genesis ID is deterministically calculated from the Genesis State.</p> <p>Calculate Genesis ID from the Genesis State</p> <pre><code>package main\n\nimport (\n\"fmt\"\n\ncore \"github.com/iden3/go-iden3-core\"\n)\n\n// Retrieve ID\nfunc main() {\n\n    id, _ := core.IdGenesisFromIdenState(core.TypeDefault, state.BigInt())\n\n    fmt.Println(\"ID:\", id)\n\n}\n</code></pre> <p>Here is what the output would look like: </p> <pre><code>ID: 11AbuG9EKnWVXK1tooT2NyStQod2EnLhfccSajkwJA\n</code></pre> <p>The identity gets published, together with all other identities, inside the struct <code>StateLib.Data internal _stateData</code> state variable, which is part of the <code>State</code> contract. While the ID remains constant, the Identity State will get updated as soon as the identity adds or revokes claims in its trees. </p> <p>No Personal Identifiable Information (PPI) is stored on-chain. From the IdState is impossible to retrieve any information (represented as claim) stored inside the Identity Claims Tree</p> <p>The Identity State hasn't been published on-chain yet as claims haven't been issued yet. This is the subject of the next section.</p> <p>The executable code can be found here</p>"},{"location":"getting-started/identity/identifier/#genesis-state","title":"Genesis State","text":"<p>There are two identity types, which differ in many aspects and because of this have two different ways to generate the Genesis State:</p> <ol> <li>Regular Identity: The Genesis State is the initial Identity State (hash of Identity SMT Roots). This identity is primarily controlled by Baby JubJub keys. At least one BJJ public key must be added into Claims Tree during the identity creation.</li> <li>Ethereum-controlled Identity: The Genesis State is derived from the Ethereum address. This identity is primarily controlled by Ethereum account from which its Genesis State and Identifier are derived.</li> </ol>"},{"location":"getting-started/identity/identifier/#w3c-did-representation","title":"W3C DID representation","text":"<p>Decentralized Identifier can be generated from the ID by prepending the DID method and network parameters in the following way:</p> <pre><code>did:&lt;method&gt;:&lt;network&gt;:&lt;subnet&gt;:&lt;id&gt;\n</code></pre> <p>Example of valid DIDs:</p> <p>1.     <pre><code>did:iden3:eth:mainnet:11AbuG9EKnWVXK1tooT2NyStQod2EnLhfccSajkwJA\n</code></pre>     where:     * <code>did:iden3</code> is DID method     * <code>eth:mainnet</code> is the network identifier for the Ethereum Mainnet     * <code>id</code>, base58-encoded id.  </p> <p>2.     <pre><code>did:polygonid:polygon:mumbai:2qCU58EJgrEMAMwdTehMoxtopwP1gKXCEt9GGeVDaG\n</code></pre>     where:     * <code>did:polygonid</code> is DID method     * <code>polygon:mumbai</code> is the network identifier for the Mumbai testnet     * <code>id</code>, base58-encoded id.  </p>"},{"location":"getting-started/identity/identity-profile/","title":"Identity Profiles","text":"<p>Identity Profiles allow users to hide their <code>Genesis Identifier</code> during interactions. Instead, users will be identified by their <code>Identity Profile</code>.</p> <p>An Identity Profile is generated by hashing the <code>id</code> with a <code>profileNonce</code> (a random number generated by the identity owner).</p> <p><pre><code>profileHash = hash(genesisId, profileNonce)\n\nprofileId = idType + profileHashCut + checksum\n</code></pre> where: * idType - identifier of DID method and blockchain network &amp; subnetwork, 2 bytes * profileHashCut - first 27 bytes of profileHash, 27 bytes * checksum - control checksum, 2 bytes * profileNonce - random number generated by the identity owner, 31 bytes (actually max ~253 bits to fit into the zk prime field)</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"math/big\"\n\n    core \"github.com/iden3/go-iden3-core\"\n)\n\n// Generate Identity Profile from Genesis Identifier\nfunc main() {\n\n    id, _ := core.IDFromString(\"11BBCPZ6Zq9HX1JhHrHT3QKUFD9kFDEyJFoAVMptVs\")\n\n    profile, _ := core.ProfileID(id, big.NewInt(50))\n\n    fmt.Println(profile.String())\n\n}\n</code></pre>"},{"location":"getting-started/identity/identity-state/","title":"Identity State","text":"<p>Each Identity State (and therefore Identity) consists of three Sparse Merkle Trees:</p> <ul> <li>Claims Tree - a tree that contains the claims issued by that particular identity.</li> <li>Revocations Tree - a tree that contains the revocation nonces of the claims that have been revoked by that particular identity.</li> <li>Roots Tree - a tree that contains the history of the tree roots from the Claims tree.</li> </ul> <p>Claims issued by an identity are added to the Claims tree (we'll see in a while why that's not always the case). The position of a claim inside the Sparse Merkle Tree is determined by the hash of the claim's <code>Index</code> while the value stored inside the leaf will be the hash of the claim's <code>Value</code>.</p> <p>An identity must issue at least one <code>Auth Claim</code> to operate properly. This is the first claim that is issued by an identity and that must be added to the <code>ClT</code>.</p> <p>An Identity State is a hash of the roots of these three merkle trees. </p> <p><code>IdState = Hash(ClR || ReR || RoR)</code> where:</p> <ul> <li><code>Hash</code>: Poseidon Hash Function</li> <li><code>ClR</code>: Claims Tree Root</li> <li><code>ReR</code>: Revocation Tree Root</li> <li><code>RoR</code>: Roots Tree Root</li> </ul> <p>The identity state gets stored on-chain and represents the status of an identity at a certain point in time.</p>  Identity State Diagram"},{"location":"getting-started/identity/identity-state/#code-examples","title":"Code Examples","text":""},{"location":"getting-started/identity/identity-state/#create-identity-trees-and-add-authclaim","title":"Create identity trees and add authClaim","text":"<pre><code>package main\n\nimport (\n    \"context\"\n    \"fmt\"\n\n    core \"github.com/iden3/go-iden3-core\"\n    \"github.com/iden3/go-merkletree-sql/v2\"\n    \"github.com/iden3/go-merkletree-sql/v2/db/memory\"\n)\n\n// Generate the three identity trees\nfunc main() {\n\n    ctx := context.Background()\n\n    // Create empty Claims tree\n    clt, _ := merkletree.NewMerkleTree(ctx, memory.NewMemoryStorage(), 40)\n\n    // Create empty Revocation tree\n    ret, _ := merkletree.NewMerkleTree(ctx, memory.NewMemoryStorage(), 40)\n\n    // Create empty Roots tree\n    rot, _ := merkletree.NewMerkleTree(ctx, memory.NewMemoryStorage(), 40)\n\n    authClaim := core.NewClaim(core.AuthSchemaHash,\n        core.WithIndexDataInts(X, Y),\n        core.WithRevocationNonce(0))\n\n    // Get the Index and the Value of the authClaim\n    hIndex, hValue, _ := authClaim.HiHv()\n\n    // add auth claim to claims tree with value hValue at index hIndex\n    clt.Add(ctx, hIndex, hValue)\n\n    // print the roots\n    fmt.Println(clt.Root().BigInt(), ret.Root().BigInt(), rot.Root().BigInt())\n}\n</code></pre> <p>We've just generated the three identity trees! For now, we only added a leaf corresponding to the <code>authClaim</code> to the Claims tree <code>ClT</code>. The Revocation tree <code>ReT</code> and the <code>RoT</code> remain empty. In particular:</p> <ul> <li>The revocation tree gets updated whenever an identity decides to revoke a claim. For instance, if a user decides to rotate her keys, then she generates a key pair, creates a new authClaim with the public key from the key pair and adds the claim to the Claims Tree. Now the user can revoke the old public key, so she adds an entry to the Revocation Tree with the claim revocation nonce as an Index and zero as a Value.</li> <li>The Roots Tree gets updated whenever the Identity Claims Tree root gets updated.</li> </ul> <p>The executable code can be found here</p> <p>Retrieve the Identity State <code>IdState</code></p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"github.com/iden3/go-merkletree-sql\"\n)\n\n// Retrieve Identity State\nfunc main() {\n\n    // calculate Identity State as a hash of the three roots\n    state, _ := merkletree.HashElems(\n        clt.Root().BigInt(),\n        ret.Root().BigInt(),\n        rot.Root().BigInt())\n\n    fmt.Println(\"Identity State:\", state)\n\n}\n</code></pre> <p>Here is what the output would look like: </p> <pre><code>Identity State: \n20698226269617404048572275736120991936409000313072409404791246779211976957795\n</code></pre> <p>The very first identity state of an identity is defined as Genesis State</p> <p>Every verification inside Iden3 protocol is executed against the Identity State. For instance, to prove the validity of a specific claim issued by A to B (in case if the claims gets added to the claims tree):</p> <ul> <li>user B needs to produce a merkle proof of the existence of that claim inside user's Claims Tree</li> <li>user B needs to produce a merkle proof of non-existence of the corresponding revocation nonce inside user's Revocations Tree</li> </ul> <p>The executable code can be found here</p>"},{"location":"getting-started/identity/identity-types/","title":"Identity Types","text":"<p>In iden3 protocol there are two types of identities, which differ in many aspects:</p> <ol> <li>Regular Identity, which is generated from three identity trees and controlled by Baby JubJub keys.</li> <li>Ethereum-controlled Identity, which is primarily controlled by Ethereum account from which it's Genesis State and    Identifier are derived.</li> </ol>"},{"location":"getting-started/identity/identity-types/#regular-identity","title":"Regular Identity","text":"<p>Regular identity is created from three merkle trees (Genesis State is a hash of Identity SMT Roots). This identity is primarily controlled by Baby JubJub keys. At least one BJJ public key must be added into Claims Tree during the identity creation.</p> <pre><code>genesisState = Hash(ClaimsTreeRoot || RevocationsTreeRoot || RootsTreeRoot)\n\ngenesisId = idType + genesisStateCut + checksum\n</code></pre> <p>where:</p> <ul> <li>idType - identifier of DID method and blockchain network &amp; subnetwork, 2 bytes</li> <li>genesisStateCut - first 27 bytes of genesisState, 27 bytes</li> <li>checksum - control checksum, 2 bytes</li> </ul>"},{"location":"getting-started/identity/identity-types/#limitations-of-regular-identity","title":"Limitations of Regular Identity","text":"<p>Currently, adding an Ethereum key to the Claims Tree and using it for authentication and proving is not practical, because it's very computationally expensive to verify ECDSA signatures in zk-circuits. Also, having the user's Ethereum address there's no way to get a user identifier from it, so dApps would need to authenticate the user additionally to get the identifier.</p>"},{"location":"getting-started/identity/identity-types/#ethereum-controlled-identity","title":"Ethereum-controlled Identity","text":"<p>This type of identity was introduced to overcome some of the limitations of regular identity - allow using Ethereum accounts to authenticate, prove statements and control identity (perform state transitions). That eliminates strict requirement to have Baby JubJub keys.</p> <p>Genesis state is always zero for Ethereum-controlled Identity.</p> <p>Genesis Identifier is directly derived from the Ethereum address in the following way:</p> <pre><code>genesisId = idType + zeroPadding + ethAddress + checksum\n</code></pre> <p>where:</p> <ul> <li>idType - identifier of DID method and blockchain network &amp; subnetwork, 2 bytes</li> <li>zeroPadding - 7 zero bytes</li> <li>ethAddress - Ethereum address of controlling Ethereum account, 20 bytes</li> <li>checksum - control checksum, 2 bytes</li> </ul> <p>Example:</p> <pre><code>idType: 0212 // DID method: PolygonID; Network: Polygon Mumbai\n+\nethAddress: 0x0dcd1bf9a1b36ce34237eeafef220932846bcd82\n+\n// uint16 sum of bytes of the byte string: idType + zeroPadding + ethAddress.\n// Note that the bytes of the uint16 are in reversed order, e.g. if sum is 0x0a45 then checksum is 0x450a\nchecksum: 450a\n===\nid: 0212000000000000000dcd1bf9a1b36ce34237eeafef220932846bcd82450a (bytes)\nid: 2qCU58EJgrELSJT6EzT27Rw9DhvwamAdbMLpePztYq (base58)\n</code></pre> <p>Note that identifiers in Smart Contracts are represented using little-endian byte order (because of how zero-knowledge proofs are verified), so the identifier for smart contracts is reversed: <pre><code>id: 000a4582cd6b84320922efafee3742e36cb3a1f91bcd0d000000000000001202 (bytes32, reversed byte order with appended zero byte in the front)\nid: 18148217572028590643859359173103611579212110941630801448409877263163593218 (uint256, same reversed bytes but encoded as uin256)\n</code></pre></p>"},{"location":"getting-started/identity/identity-types/#did-representation","title":"DID representation","text":"<p>Canonical form is the same as for Regular Identity:</p> <pre><code>did:polygonid:polygon:mumbai:2qCU58EJgrELSJT6EzT27Rw9DhvwamAdbMLpePztYq\n</code></pre>"},{"location":"getting-started/identity/identity-types/#authentication-method","title":"Authentication Method","text":"<p>Ethereum-controlled Identity can be authenticated by verifying if the Identifier matches the Ethereum account that sent a transaction (<code>msg.sender</code>).</p> <p>In case Ethereum-controlled Identity performs State Transition and adds BJJ keys to it's Claims Tree, it can also perform authentication by ZKP using BJJ keys.</p>"},{"location":"getting-started/identity/identity-types/#ethereum-account-types","title":"Ethereum Account Types","text":"<p>Ethereum has two types of accounts:</p> <ul> <li>Smart Contract (SC)</li> <li>Externally Owned Account (EOA)</li> </ul>"},{"location":"getting-started/identity/identity-types/#smart-contract-sc","title":"Smart Contract (SC)","text":"<p>Smart contracts can control identity and perform state transitions. In case such a smart contract manages its identity trees on chain, it becomes an OnChain Identity.</p>"},{"location":"getting-started/identity/identity-types/#externally-owned-account-eoa","title":"Externally Owned Account (EOA)","text":"<p>Note: The EOA-controlled identity is not yet fully supported in iden3 protocol (WIP).</p>"},{"location":"getting-started/identity/identity-types/#limitations-of-ethereum-controlled-identity","title":"Limitations of Ethereum-controlled Identity","text":"<ul> <li>Only one Ethereum account can control identity</li> <li>No support for Ethereum key rotation and revocation. It's embedded into Identifier directly</li> <li>No support for profiles. It's not possible to hide genesis identifier and use profile instead when using Ethereum key   to authenticate &amp; prove statements.</li> <li>No support for credential issuance with BJJ signature, only SMT proofs available.</li> </ul> <p>The last two limitations can be overcome by adding BJJ keys to Claims Tree and performing state transition. Afterwards, it's possible to use BJJ keys for authentication, proving &amp; credential issuance. See Identity Type Comparison for more details.</p>"},{"location":"getting-started/identity/identity-types/#identity-type-comparison","title":"Identity Type Comparison","text":"Aspect Regular Identity Ethereum-controlled Identity Ethereum-controlled Identity with added BJJ keys Genesis State Identity State Ethereum Address Ethereum Address Keys BJJ keys Ethereum Account (SC or EOA) Ethereum Account (SC or EOA) + BJJ keys Authentication Method (off-chain) JWZ with ZKP using BJJ keys JWS with Ethereum Signature JWS with Ethereum Signature or JWZ with ZKP using BJJ keys Authentication Method (on-chain) ZKP using BJJ keys Ethereum Account Ethereum Account or ZKP using BJJ keys State Transition Method ZKP using BJJ keys Ethereum Account * Ethereum Account or ZKP using BJJ keys Key Rotation Support Only BJJ keys Can add BJJ keys Only BJJ keys Profiles Support Yes No Yes Credential Issuance with MTP proof Yes Yes Yes Credential Issuance with Sig proof Yes No Yes Credential Revocation Support Yes Yes Yes <p>* Take into account the data consistency warnings described in relevant OnChain Identity section. </p>"},{"location":"getting-started/identity/onchain-identity/","title":"OnChain Identity","text":"<p>An OnChain Identity is an identity that is controlled by a smart contract. It is a special case of Ethereum-controlled Identity.</p> <p>An OnChain Identity manages its own identity trees on-chain (claims, revocation, and roots trees). It can issue credentials (by adding them to its claims tree), revoke credentials, and perform state transitions to update its overall state.</p>"},{"location":"getting-started/identity/onchain-identity/#onchain-issuer","title":"OnChain Issuer","text":"<p>An OnChain Issuer is a specialized OnChain Identity used to issue credentials to other identities.</p>"},{"location":"getting-started/identity/onchain-identity/#libraries-and-contracts","title":"Libraries and Contracts","text":"<ul> <li>IdentityLib.sol - A library that can create identities, manage trees, issue or revoke credentials, and perform state transitions.</li> <li>GenesisUtils.sol - A library that can generate an identity ID from an Ethereum address or genesis identity state, and verify the ID's structure.</li> <li>IdentityBase.sol - A base contract for building OnChain Identity or Issuer contracts, with the required public interfaces implemented.</li> </ul>"},{"location":"getting-started/identity/onchain-identity/#benefits-possible-use-cases","title":"Benefits &amp; Possible Use Cases","text":""},{"location":"getting-started/identity/onchain-identity/#programmable-identity","title":"Programmable Identity","text":"<p>OnChain Identities can have custom logic implemented in their smart contract code to manage credentials and keys. For example, an OnChain Identity can require multi-signature approval for issuing or revoking credentials, or implement time-based restrictions on certain actions.</p>"},{"location":"getting-started/identity/onchain-identity/#composable","title":"Composable","text":"<p>OnChain Identities are smart contracts, which means they can include other smart contract logic to extend their functionality.  For example, an OnChain Identity can be a Smart Account Wallet that allows users to manage their funds and identity in a single contract and benefit from features like social recovery, gasless transactions, and more. They can also interact with other smart contracts and DeFi protocols, enabling identity-aware interactions in use cases such as reputation-based lending or insurance.</p>"},{"location":"getting-started/identity/onchain-identity/#transparent-and-auditable","title":"Transparent and Auditable","text":"<p>Smart contract code defines rules, such as who and how is issuing credentials or rotating keys. This code is public and can be audited by anyone. This increases trust in the system, as users can verify that the identity behaves as expected.</p>"},{"location":"getting-started/identity/onchain-identity/#self-issuance-trustless-decentralized-issuance","title":"Self-Issuance / Trustless Decentralized Issuance","text":"<p>Users can interact with the smart contract to issue themselves credentials that are valid and verifiable, exactly like those issued by regular off-chain issuers. This allows users to make their existing reputation portable and usable in a privacy-preserving manner, such as proving balance, NFT ownership, or trade volumes without revealing their addresses and exact amounts. And there is no need to trust a third party for proper user verification and credential issuance. The smart contract can enforce the correct behavior.</p>"},{"location":"getting-started/identity/onchain-identity/#zk-enabled-self-issuance-with-private-data","title":"ZK-Enabled Self-Issuance with Private Data","text":"<p>It is also possible to leverage private data sources, such as digitally signed documents (e.g., e-Passports, emails with DKIM signatures, signed PDFs), to issue credentials in a privacy-preserving manner using zero-knowledge proofs. A user can create credentials on their own device and prove that they were created correctly, following the rules of a smart contract and a specific ZK circuit. For example, a user uses a mobile phone to read their biometric passport and generates a verifiable credential based on its data. A ZK circuit then proves that the resulting credential corresponds to the passport data, and that this data is properly signed by valid government keys. Only the hash of the credential, along with a zero-knowledge proof, is sent on-chain to be verified and added to the OnChain Identity's claims tree. This ensures that private data never leaves the user's device, while the user still receives a valid credential.</p>"},{"location":"getting-started/identity/onchain-identity/#identity-recovery","title":"Identity Recovery","text":"<p>If a user loses access to their keys, it is possible to implement a recovery mechanism in the smart contract. For example, a set of trusted parties (friends, family members, DAO members, etc.) can vote to give access back to the user by adding a new authentication key to user's OnChain Identity. Alternatively, the user can present a zero-knowledge proof that they control another identity with a credential stating it is the same real-world identity (e.g., based on a self-issued zk passport credential or a KYC credential from a trusted issuer), and request to add a new authentication key and revoke the old one.</p>"},{"location":"getting-started/identity/onchain-identity/#smart-governance","title":"Smart Governance","text":"<p>OnChain Identities can implement governance mechanisms allowing multiple parties to manage the identity collaboratively. For example, a DAO may vote to issue or revoke a credential (such as an executive or validator role) of a specific user.</p>"},{"location":"getting-started/identity/onchain-identity/#organizational-identity-management","title":"Organizational Identity Management","text":"<p>Organizations can use OnChain Identities to manage their members' and clients' credentials. For example, a company can have an OnChain Identity that issues credentials to its employees, such as right to represent the company in certain transactions or access specific resources such as instant messaging channels, internal tools and physical locations. The company can also revoke credentials when an employee leaves, so that access is automatically removed.</p>"},{"location":"getting-started/identity/onchain-identity/#onchain-identity-state-transition","title":"OnChain Identity State Transition","text":"<p>An OnChain Identity state transition is performed by calling the <code>transitState</code> function of the <code>IdentityLib</code> library. This function calculates new state from the claims, revocations and roots tree roots, which collectively define the current identity's status. It also verifies whether the roots have changed since the last state transition, due to claims or revocations added to the relevant trees.</p> <p>Finally, it calls <code>transitStateGeneric</code> function of the <code>State</code> contract, which is designed to be generic and may be used in the future to perform state transitions for other types of identities or transition logic.</p>"},{"location":"getting-started/identity/onchain-identity/#state-data-consistency-warning","title":"State data consistency warning","text":"<p>Please note that neither the <code>State</code> contract nor <code>IdentityLib</code> impose restrictions on users who perform a state transition using <code>IdentityLib.transitState()</code>, and then subsequently perform another state transition using the <code>State.transitState()</code> contract with BJJ key authentication. This sequence of actions may result in inconsistent state data between the <code>State</code> and OnChain Identity smart contracts. It is the sole responsibility of the OnChain Identity owner to prevent such situations.</p>"},{"location":"getting-started/signature-claim/signature/","title":"Signature Claim Issuance","text":"<p>To issue a claim by signing it, the only thing needed is access to your Baby Jubjub private key.</p> <p>1.Retrieve hash of Claim's Index and hash of Claim's Value</p> <p>Starting from the Generic Claim previously created the first step we first need to extract the hash of its index and the hash of its value</p> <pre><code>claimIndex, claimValue := claim.RawSlots()\nindexHash, _ := poseidon.Hash(core.ElemBytesToInts(claimIndex[:]))\nvalueHash, _ := poseidon.Hash(core.ElemBytesToInts(claimValue[:]))\n</code></pre> <p>2.Hash the <code>indexHash</code> and the <code>valueHash</code> together and sign it</p> <pre><code>// Poseidon Hash the indexHash and the valueHash together to get the claimHash\nclaimHash, _ := merkletree.HashElems(indexHash, valueHash)\n\n// Sign the claimHash with the private key of the issuer\nclaimSignature := babyJubjubPrivKey.SignPoseidon(claimHash.BigInt())\n</code></pre> <p>The executable code can be found here</p>"},{"location":"getting-started/state-transition/new-identity-state/","title":"Add Claim to the Claims Tree","text":"<p>At t=0, the situation is the same left from the Identity section of tutorial. Our identity is still at the <code>Genesis State</code>. The Claims Tree contains only the <code>authClaim</code>. The revocation and roots trees are empty. The state hasn't been published on-chain yet.</p> <p>Let's see what happens when if we decide to add a new claim to the Claims Tree.</p> <p>1.Update the required dependencies.</p> <pre><code>go get github.com/iden3/go-circuits\n</code></pre> <p>2.Add a new claim and fetch the new state</p> <pre><code>package main\n\nimport (\n    \"encoding/hex\"\n    \"fmt\"\n    \"math/big\"\n\n    \"github.com/iden3/go-circuits\"\n    core \"github.com/iden3/go-iden3-core\"\n    \"github.com/iden3/go-iden3-crypto/poseidon\"\n    \"github.com/iden3/go-merkletree-sql\"\n)\n\n// Change Identity State\nfunc main() {\n    // GENESIS STATE:\n\n    // 1. Generate Merkle Tree Proof for authClaim at Genesis State\n    authMTPProof, _, _ := clt.GenerateProof(ctx, hIndex, clt.Root())\n\n    // 2. Generate the Non-Revocation Merkle tree proof for the authClaim at Genesis State\n    authNonRevMTPProof, _, _ := ret.GenerateProof(ctx, new(big.Int).SetUint64(revNonce), ret.Root())\n\n    // Snapshot of the Genesis State\n    genesisTreeState := circuits.TreeState{\n        State:          state,\n        ClaimsRoot:     clt.Root(),\n        RevocationRoot: ret.Root(),\n        RootOfRoots:    rot.Root(),\n    }\n    // STATE 1:\n\n    // Before updating the claims tree, add the claims tree root at Genesis state to the Roots tree.\n    rot.Add(ctx, clt.Root().BigInt(), big.NewInt(0))\n\n    // Create a new random claim\n    schemaHex := hex.EncodeToString([]byte(\"myAge_test_claim\"))\n    schema, _ := core.NewSchemaHashFromHex(schemaHex)\n\n    code := big.NewInt(51)\n\n    newClaim, _ := core.NewClaim(schema, core.WithIndexDataInts(code, nil))\n\n    // Get hash Index and hash Value of the new claim\n    hi, hv, _ := newClaim.HiHv()\n\n    // Add claim to the Claims tree\n    clt.Add(ctx, hi, hv)\n\n    // Fetch the new Identity State\n    newState, _ := merkletree.HashElems(\n        clt.Root().BigInt(),\n        ret.Root().BigInt(),\n        rot.Root().BigInt())\n\n    // Snapshot of the new tree State\n    newTreeState := circuits.TreeState{\n        State:          newState,\n        ClaimsRoot:     clt.Root(),\n        RevocationRoot: ret.Root(),\n        RootOfRoots:    rot.Root(),\n    }\n\n    // Sign a message (hash of the genesis state + the new state) using your private key\n    hashOldAndNewStates, _ := poseidon.Hash([]*big.Int{state.BigInt(), newState.BigInt()})\n\n    signature := babyJubjubPrivKey.SignPoseidon(hashOldAndNewStates)\n\n    authClaimNewStateIncMtp, _, _ := clt.GenerateProof(ctx, hIndex, newTreeState.ClaimsRoot)\n\n    // Generate state transition inputs\n    stateTransitionInputs := circuits.StateTransitionInputs{\n        ID:                      id,\n        OldTreeState:            genesisTreeState,\n        NewTreeState:            newTreeState,\n        IsOldStateGenesis:       true,\n        AuthClaim:               authClaim,\n        AuthClaimIncMtp:         authMTPProof,\n        AuthClaimNonRevMtp:      authNonRevMTPProof,\n        AuthClaimNewStateIncMtp: authClaimNewStateIncMtp,\n        Signature:               signature,\n    }\n\n    // Perform marshalling of the state transition inputs\n    inputBytes, _ := stateTransitionInputs.InputsMarshal()\n\n    fmt.Println(string(inputBytes))\n}\n</code></pre> <p>After issuing a new claim, the claims tree gets modified and, therefore, the Identity State changes. To complete the state transition it is necessary to verify it inside a circuit. The type <code>StateTransitionInputs</code> lets us pack the inputs needed to generate a proof while the <code>InputsMarshal()</code> function turns it into a json file that can be used directly as State Transition Circuit inputs. These inputs will be used in the next section.</p> <p>The executable code can be found here</p>"},{"location":"getting-started/state-transition/on-chain-state-transition-remix/","title":"On chain state transition remix","text":""},{"location":"getting-started/state-transition/on-chain-state-transition-remix/#remix","title":"Remix","text":"<ol> <li> <p>Connect yout Metamask wallet to Polygon Mumbai Testnet.</p> </li> <li> <p>On the Remix Homepage, click \"Load from GitHub\" and import <code>State.sol</code> using the link: https://github.com/iden3/contracts/blob/master/contracts/State.sol</p> </li> <li> <p>Move to the \"Solidity Compiler\" section and compile <code>State.sol</code>.</p> </li> <li> <p>Move to the \"Deploy and Run Transaction\" section and modify the Environment to \"Injected web3\". If everything was set correctly, you should see <code>Custom (80001) network</code> below the environment drop-down menu.The system prompts you to connect to your MetaMask wallet. Make sure to select the \"Mumbai\" network on your Metamask before connecting the wallet. </p> </li> <li> <p>Make sure that the State contract is selected in the contract drop-down menu and \"Load contract from address\" adding 0x46Fd04eEa588a3EA7e9F055dd691C688c4148ab3 as contract address.</p> </li> <li> <p>Check identity state at T=0. To check the identity state call the getState function on the State.sol passing in your identifier. The identifier is the first public input in the public array returned from the solidity calldata from the previous tutorial. The result is zero as there's no identity state associated with that identifier because the identity state has never been published on-chain (yet!) </p> </li> <li> <p>Now update the identity state by calling the <code>transitState</code> function on State.sol. </p> <p>The outputs generated from the previous tutorial are passed as inputs to the <code>transitState</code> function. See the one-to-one mapping between the outputs from state transition and the inputs to the <code>transitState</code> function in the diagram below:</p> <p>  transitState Function Inputs  <li> <p>Check the new state. To check, call the <code>getState</code> function again by passing the value of the identifier you used above as an input to the <code>transitState</code> function. </p> </li> <p>You can see that the console displays a new state:</p> <p><code>uint256:14531895531750268543323474544059484523319511522635242711319115705040584883009</code></p>"},{"location":"getting-started/state-transition/on-chain-state-transition/","title":"Verify the Proof On-Chain","text":"<p>In order to complete the State Transition process it is necessary to verify the proof inside the <code>State.sol</code> contract.</p> <p>The <code>transitState</code> public function of the contract takes the proof generated in the previous section and verifies it on-chain. On verification, the <code>identities</code> mapping associated with the <code>ID</code> that is executing the transition gets updated.</p>"},{"location":"getting-started/state-transition/on-chain-state-transition/#hardhat","title":"Hardhat","text":"<p>1.Add Mumbai Network inside your <code>hardhat.config.js</code></p> <pre><code>networks: {\n   mumbai: {\n      url: `${process.env.MUMBAI_RPC_URL}`,\n      accounts: [`${process.env.MUMBAI_PRIVATE_KEY}`]\n   }\n}\n</code></pre> <p>2.Add State.sol contract and its dependencies (Poseidon.sol and Smt.sol) inside the contracts folder</p> <p>3.Import the state contract from the existing Mumbai testnet address</p> <pre><code>const contract = await hre.ethers.getContractAt(\"State\", \"0xEA9aF2088B4a9770fC32A12fD42E61BDD317E655\");\n</code></pre> <p>4.Add inputs from the proof generated in the previous section</p> <pre><code>   const id = \"0x000a501c057d28c0c50f91062730531a247474274ff6204a4f7da6d4bcb70000\"\n  const oldState = \"0x1c057d28c0c50f91062730531a247474274ff6204a4f7da6d4bcb7d23be4d605\"\n  const newState = \"0x203034fdafe4563e84962f2b16fefe8ebedb1be5c05b7d5e5e30898d799192fd\"\n  const isOldStateGenesis = \"0x0000000000000000000000000000000000000000000000000000000000000001\"\n\n  const a = [\"0x0c98dbb5bcdc4810a976b9804972c6086e855532740ab2c611fbcf4a5d939f91\", \"0x1f3b6aa1cfe69a2a3f5e8e7db5ccae0d269fc66be6d0c364469486d5718431ee\"]\n  const b = [[\"0x21f67821a25f3b0eb008e8aa840706c6dd9c1cff16ec6f138d7745aff350dbbb\", \"0x255b9f12a90b1f1089af5edcda19fb6d592096f6ba7ce2438ce4ecc48399687d\"],[\"0x1568f9a5a84d72a31b90d26b5035030b0b02544dcba18f0a3740f80b9632942d\", \"0x28dcba6dd58878a3383fd556d27118a3e905f424d23afa30b71de3ac000822de\"]]\n  const c = [\"0x15adbb5f1abe4418a7ea7f876164b57bf70f88183fa7d85406be4cb5f8fee261\", \"0x04466d6e7131a89fdcf5136b52ed2b52e00755ad77c97bb87e8afa690eeef5e4\"]\n</code></pre> <p>Note: Do not use these same inputs for the next section of the tutorial. I already executed the State Transition using these inputs, so the transaction will fail. Instead, use the inputs that you locally generated.</p> <p>5.Execute state transition function</p> <pre><code>await contract.transitState(id, oldState, newState, isOldStateGenesis, a, b, c);\n</code></pre> <p>6.Fetch identity state after state transition</p> <pre><code>// Get state of identity without BigNumber\nlet identityState = await contract.getStateInfoById(id);\n\nconsole.log(\"Identity State after state transition\", identityState.id);\n// 18221365812082731933036101625854358571814024255404073202903829924181114880\n</code></pre> <p>Congratulations! You have successfully completed the identity state transition. </p> <p>Starting from the identifier, people will be able to track the status of an identity in a timestamped and tamper-proof way. The identifier remains fixed for the entire existence of an identity, while the identity state changes every time an identity gets updated, for example, when issuing or revoking a claim. As we'll see in the next section, every ZK proof generated from an identity will be checked against the identity state published on-chain.</p> <p>It is important to underline that:</p> <ul> <li>The mapping that associates an identifier with its current identity state is the only piece of information stored on-chain. </li> <li>Starting from the identifier and the identity state, it is impossible to retrieve any information stored in the identity trees, for example, reading the content of a claim (which is stored off-chain).</li> <li>There is no association between the ECDSA (Elliptical Curve Digital Signature Algorithm) key pair associated with the Ethereum address that executes the State Transition and the Baby Jubjub key pair which is used to control an identity.</li> </ul> <p>The executable code can be found here</p>"},{"location":"getting-started/state-transition/state-transition-proof/","title":"Generate Proof for State Transition","text":"<p>The output of the previous tutorial was the result of a locally executed computation by the Identity Owner, namely moving from the genesis state to state 1. </p> <p>What if the person that executed the state transition wasn't actually the Identity Owner? What if the key used to sign the message was revoked? </p> <p>To ensure the state transition happens in a trustless way, it must be verified inside a circuit. </p> <p>The State Transition inputs generated earlier will be passed into the State Transition Circuit to generate a proof of the executed state transition. </p> <p>1.Install Circom and SnarkJS.</p> <p>2.Clone the repository that contains the compiled circuit</p> <pre><code>git clone https://github.com/iden3/tutorial-examples.git\n</code></pre> <p>This repository contains the <code>stateTransition</code> compiled circuit after a trusted setup.</p> <p>3.Create a .json file with the state transition inputs from the previous tutorial</p> <p>For this, create a file named <code>input.json</code> inside the <code>.stateTransition/stateTransition_js</code> and then paste the inputs you generated in the previous tutorial. These inputs will be passed to the circuit and will be used to generate the zk proof.</p> <p>4.Generate the proof</p> <p>From the compiled-circuits folder run:</p> <pre><code>./generate.sh stateTransition\n</code></pre> <p>If everything worked fine, your terminal should display: </p> <pre><code>[INFO]  snarkJS: OK!\n</code></pre> <p>5.Display the proof</p> <p>You should now have 2 new files inside the /stateTransition/stateTransition_js directory, namely proof.json and public.json:</p> <ul> <li> <p><code>proof.json</code> contains the actual proof represented by the three arrays <code>a, b, and c</code>. It contains all the raw data of the proof that the SnarkJS library uses for verification of the proof.</p> </li> <li> <p><code>public.json</code> is an array of the four elements representing the public inputs of the circuit. These are <code>userID,oldUserState,newUserState,isOldStateGenesis</code></p> </li> </ul> <p>6.Export the proof in the Solidity calldata.</p> <p>The two files from the above step can also be exported as Solidity calldata in order to execute the verification on-chain. From the <code>stateTransition_js</code> directory run <code>snarkjs generatecall</code>.</p> <p><pre><code>snarkjs generatecall\n</code></pre> Here is what the output would look like: </p> <pre><code>[\"0x0c98dbb5bcdc4810a976b9804972c6086e855532740ab2c611fbcf4a5d939f91\", \"0x1f3b6aa1cfe69a2a3f5e8e7db5ccae0d269fc66be6d0c364469486d5718431ee\"],[[\"0x21f67821a25f3b0eb008e8aa840706c6dd9c1cff16ec6f138d7745aff350dbbb\", \"0x255b9f12a90b1f1089af5edcda19fb6d592096f6ba7ce2438ce4ecc48399687d\"],[\"0x1568f9a5a84d72a31b90d26b5035030b0b02544dcba18f0a3740f80b9632942d\", \"0x28dcba6dd58878a3383fd556d27118a3e905f424d23afa30b71de3ac000822de\"]],[\"0x15adbb5f1abe4418a7ea7f876164b57bf70f88183fa7d85406be4cb5f8fee261\", \"0x04466d6e7131a89fdcf5136b52ed2b52e00755ad77c97bb87e8afa690eeef5e4\"],[\"0x000a501c057d28c0c50f91062730531a247474274ff6204a4f7da6d4bcb70000\",\"0x1c057d28c0c50f91062730531a247474274ff6204a4f7da6d4bcb7d23be4d605\",\"0x203034fdafe4563e84962f2b16fefe8ebedb1be5c05b7d5e5e30898d799192fd\",\"0x0000000000000000000000000000000000000000000000000000000000000001\"]\n</code></pre> <p>The Solidity calldata output represents: </p> <pre><code>- `a[2]`, `b[2][2]`, `c[2]`, namely the proof\n- `public[4]`, namely the public inputs of the circuit\n</code></pre> <p>In the next tutorial, we shall pass this proof to the State.sol smart contract in order to complete the State Transition function.</p>"},{"location":"getting-started/state-transition/state-transition/","title":"State Transition","text":"<p>When an identity adds a new claim to her Claims Tree, the root of the tree and, consequently, the identity state change. The process of moving from one state to another is defined using State Transition Function.</p> <p>Before performing changing states of identity, State Contract verifies the State Transition Function proof. </p> <p>This proof can be: * A ZK proof generated by the prover using the State Transition Circuit and BJJ keys. * An Ethereum transaction executed by the identity owner (for Ethereum-controlled Identities).</p>"},{"location":"getting-started/state-transition/state-transition/#zk-state-transition-verifier","title":"ZK State Transition Verifier","text":"<p>State Contract has <code>transitState</code> smart contract function, which verifies proof of <code>stateTransition</code> circuit, which represents a set of rules that identity holder needs to follow to complete the state transition such as:</p> <ul> <li>The prover is the owner of the identity (checked using a digital signature by the private key corresponding the <code>authClaim</code>)</li> <li>The <code>authClaim</code> of the prover hasn't been revoked.</li> </ul> <p>The identity state gets updated by calling the <code>transitState</code> smart contract function. To call this function, it is necessary to pass in the proof generated previously.</p>"},{"location":"getting-started/state-transition/state-transition/#ethereum-state-transition-verifier","title":"Ethereum State Transition Verifier","text":"<p>Ethereum State Transition requires a <code>msg.sender</code> of an Ethereum transaction to match identifier provided. </p>"},{"location":"getting-started/state-transition/state-transition/#state-transition-process","title":"State Transition Process","text":"<p>After successful verification, the <code>identities</code> mapping gets updated associating the <code>ID</code> with a new <code>IdState</code>, and GIST gets updated with the new <code>IdState</code> value.</p> <p>This tutorial is split in 3 parts:</p> <ol> <li>Add Claim to the Claims Tree</li> <li>Generate ZK Proof for State Transition</li> <li>Verify ZK Proof On-Chain</li> </ol> <p>Note: The Identity State Transition happens not only when an identity adds a new claim to the Claims Tree, but also when a claim gets updated or revoked (by adding it to the revocation tree).</p>"},{"location":"guides/centralized-login/","title":"Centralized Login Use Case","text":""},{"location":"guides/centralized-login/#overview","title":"Overview","text":"<p>This document will guide you through the steps required to integrate iden3's technology into your application's login.</p>"},{"location":"guides/centralized-login/#introduction","title":"Introduction","text":"<p>Iden3 is a complete decentralized identity management solution that allows users to leverage their pre-existing validated identities. This helps these users prove that they are who they claim to be; thus saving them the hassle of registering with each service (each requiring a validated identification) individually. One of the direct applications of the iden3 technology is to allow web services to reuse these identities for logging into their portals.</p> <p>The diagram below shows the steps of the backend process; follow these to enable a user gain access to your application using the iden3 identity system once the s/he has requested to log in.</p> <p> Iden3 provides an SDK to take care of requesting and verifying the identity so that the users can be authenticated.</p>"},{"location":"guides/centralized-login/#platforms-supported","title":"Platforms Supported","text":"<ul> <li> <p>JavaScript: https://github.com/iden3/iden3js</p> </li> <li> <p>Go: https://github.com/iden3/go-iden3</p> </li> </ul>"},{"location":"guides/centralized-login/#pre-requirements","title":"Pre-requirements","text":"<p>The minimum requirements for a functional centralized login include:</p> <ol> <li>The iden3 wallet service has been deployed.</li> <li>A user attempting to log in has at least one valid identity.</li> </ol>"},{"location":"guides/centralized-login/#integration","title":"Integration","text":"<p>A JavaScript reference implementation of how a third-party can integrate the iden3 solution to log in to its application can be found at: https://github.com/iden3/centralized-login-demo.  In this example, the external service includes a front-end and a back-end server. Let's see how this division into the front-end and the back-end actually works:</p>"},{"location":"guides/centralized-login/#front-end","title":"Front-End","text":"<p>On the front-end, you need to embed a button to initiate the login process. You will also need to display a QR code that the user can scan to complete the authentication. After the button is pressed, the front-end makes a request to the back-end to start the identity authentication process and waits for the response containing the QR code to be displayed and scanned by the user.</p> <p>In the reference implementation, this is achieved by the JavaScript function getLoginData(), found in frontend/index.js. This code shows how to:</p> <ol> <li>Send a request for a new requestIdenAssert packet to the centralized application back-end.</li> <li>Open a WebSocket between the front-end and back-end.</li> <li>Display a QR code containing the requestIdenAssert packet to be signed by iden3's wallet.</li> </ol>"},{"location":"guides/centralized-login/#back-end","title":"Back-End","text":""},{"location":"guides/centralized-login/#generating-requests-of-identity-assertion","title":"Generating Requests of Identity Assertion","text":"<p>On the back-end, you will need to prepare a new API endpoint to handle the requestIdenAssert() petitions from the front-end. In the reference implementation, we use GET/login by calling the JavaScript function:</p> <pre><code>const signatureRequest = iden3.protocols.login.newRequestIdenAssert(nonceDB, origin, timeout);\n</code></pre> <p>or the Go function:</p> <pre><code>requestIdenAssert := NewRequestIdenAssert(nonceDb, origin, timeout)\n</code></pre> <p>where:</p> <ul> <li>nonceDB is a NonceDB object generated by calling an API function and stored in a RAM database.</li> <li>origin is the domain of the emitter of the request, for example, myweb.com.</li> <li>timeout is the timeout in seconds, for example, two minutes (120s).</li> </ul> <p>The nonceDB is obtained by calling the following JavaScript function:</p> <pre><code>const nonceDB = new iden3.protocols.NonceDB();\n</code></pre> <p>or the Go function:</p> <p>``` {.sourceCode .c nonceDb := core.NewNonceDb()} <pre><code>Once you have the *signatureRequest* object, you can return it back to the front-end so that it can be displayed.\n\n#### Verifying signedPacket\n\nOn the back-end, you will also need to prepare a new API endpoint to handle the responses from the iden3 wallet containing the *signedPacket*. In the reference implementation, we use *POST /login* to allow the walled to send the signed data.\n\nTo perform the verification in the newly added endpoint you just need to call the *iden3js* library:\n\n``` {.sourceCode .javascript}\nconst verified = iden3.protocols.login.verifySignedPacket(nonceDB, origin, signedPacket);\n</code></pre></p> <p>or the go-iden3 library:</p> <pre><code>verified, err := signedPacketVerifier.\n    VerifySignedPacketIdenAssert(signedPacket, nonceDB, origin)\n</code></pre> <p>where:</p> <ul> <li>nonceDB is the NonceDB object generated earlier.</li> <li>origin is the domain of the emitter of the request, for example, myweb.com.</li> <li>signedPacket  is the signed packet sent by the iden3 wallet.</li> <li>verified is null if verification fails.</li> </ul>"},{"location":"guides/centralized-login/#sdk-installation","title":"SDK Installation","text":""},{"location":"guides/centralized-login/#iden3js","title":"iden3js","text":""},{"location":"guides/centralized-login/#installation","title":"Installation","text":"<pre><code>npm install --save @iden3/iden3\n</code></pre>"},{"location":"guides/centralized-login/#import","title":"Import","text":"<pre><code>const iden3 = require('iden3');\n</code></pre>"},{"location":"guides/centralized-login/#go-iden3","title":"go-iden3","text":""},{"location":"guides/centralized-login/#installation_1","title":"Installation","text":"<pre><code>go get github.com/iden3/go-iden3\n</code></pre>"},{"location":"guides/centralized-login/#import_1","title":"Import","text":"<pre><code>import { \"github.com/iden3/go-iden3/services/signedpacketsrv\" }\n</code></pre>"},{"location":"guides/circom-and-snarkjs/","title":"How to Use Circom and SnarkJS?","text":"<p>Hello and welcome!!</p> <p>In this guide, we'll explain how to create your first zero-knowledge Snark circuit using Circom and SnarkJS.</p> <p>Circom is a library that allows you to build circuits to be used in zero-knowledge proofs. </p> <p>While SnarkJS is an independent implementation of the zk-SNARK protocol (fully written in JavaScript), Circom is designed to work with SnarkJS. In other words, any circuit you build in Circom can be used in SnarkJS.</p> <p>We'll start by covering various techniques to write circuits; then we shall move on to creating and verifying a proof off-chain, and finally, finish it off by repeating this process on-chain (on Ethereum).</p> <p>If you have zero knowledge about zero-knowledge \ud83d\ude0b or are unsure about what a zk-SNARK is, we recommend you read this page first.</p> <p>To get started, click here.</p>"},{"location":"protocol/bjjkey/","title":"AuthBJJCredential","text":"<p>AuthBJJCredential is a primary credential for each identity. It represents an authorization operational key. Hex of the current auth claim schema is ca938857241db9451ea329256b9c06e5. This claim must be presented in most circuits for identity verification.</p> <p>A Baby Jubjub key uses a specific elliptic curve defined over the large prime subgroup of the BN128 elliptic curve. To know more about the bjj key, you can visit this page.</p> <p>X and Y values of the bjj public key are part of the Index data slots [I_2] and [I_3].</p> <p>You can find below an example of a claim entry:</p> <pre><code>Index:\n i_0: [ 128 bits] 269270088098491255471307608775043319525 // auth schema (big integer from ca938857241db9451ea329256b9c06e5)\n      [ 32 bits ] 00010000000000000000 // header flags: first 000 - self claim 1 - expiration is set. \n      [ 32 bits ] 0\n      [ 61 bits ] 0 \n i_1: [ 253 bits] 0\n i_2: [ 253 bits] 15730379921066174438220083697399546667862601297001890929936158339406931652649 // x part of BJJ pubkey\n i_3: [ 253 bits] 5635420193976628435572861747946801377895543276711153351053385881432935772762  // y part of BJJ pubkey\nValue:\n v_0: [ 64 bits ] 2484496687 // revocation nonce\n      [ 64 bits ] 1679670808 // expiration timestamp\n      [ 125 bits] 0\n v_1: [ 253 bits] 0\n v_2: [ 253 bits] 0\n v_3: [ 253 bits] 0\n</code></pre>"},{"location":"protocol/circuits/","title":"Circuits","text":""},{"location":"protocol/circuits/#template-docs-example","title":"Template Docs Example","text":"<p>Let's understand how circuits and templates can be described by their graphs. Just compare the following .circom code with its visual graph displayed underneath.</p> <p>The code: <pre><code>template Example () {\nsignal input input1;\nsignal input input2;\nsignal input input3;\nsignal input input4;\nsignal input input5;\n\n    component template1 = Template1();\n    template1.in1 = input1;\n    template1.in2 = input2;\n    template1.in3 = input3;\n\n    component template2 = Template2();\n    template2.in1 = input3;\n    template2.in2 = input4;\n}\n</code></pre></p> <p>The graph: <pre><code>graph TB\n    Input1 --&gt; Template1\n    Input2 --&gt; Template1\n    Input3 --&gt; Template1\n    Input3 --&gt; Template2\n    Input4 --&gt; Template2\n\n    classDef inputStyle fill:#ecb3ff\n    class Input1,Input2,Input3,Input4,Input5,Input6,Input7,Input8,Input9 inputStyle\n\n    classDef circuitStyle fill:#b3ffd4,stroke-width:3px;  \n    class Template1,Template2,Template3 circuitStyle;</code></pre></p>"},{"location":"protocol/circuits/#basic-templates","title":"Basic Templates","text":"<p>Basic templates are not used independently to create circuits but are used as the building blocks for other templates.</p>"},{"location":"protocol/circuits/#checkclaimexists","title":"checkClaimExists","text":"<p>This circuit checks if a claim exists in the sparse Merkle tree. By \"exists\", we mean that a value Hv (hash of all values slots) is located by path Hi (hash of all index slots) in the tree.</p> <pre><code>graph TB\n    claim --&gt; getClaimHiHv\n    getClaimHiHv -- key --&gt; SMTVerifier[SMTVerifier]\n    getClaimHiHv -- value --&gt; SMTVerifier\n    claimMTP -- siblings --&gt; SMTVerifier\n    treeRoot -- root --&gt; SMTVerifier\n    1 -- enabled --&gt; SMTVerifier\n    zero1[0] -- fnc --&gt; SMTVerifier\n    zero2[0] -- oldKey --&gt; SMTVerifier\n    zero3[0] -- oldValue --&gt; SMTVerifier\n    zero4[0] -- isOld0 --&gt; SMTVerifier\n\n    classDef inputStyle fill:#ecb3ff\n    class claim,claimMTP,treeRoot inputStyle\n\n    classDef circuitStyle fill:#b3ffd4,stroke-width:3px;  \n    class getClaimHiHv,SMTVerifier circuitStyle;</code></pre>"},{"location":"protocol/circuits/#checkclaimnonrev","title":"checkClaimNonRev","text":"<p>The circuit checks that the claim does not exist in the sparse Merkle tree. That means that the tree leaf is empty by a path, which is defined by the claim nonce.</p> <pre><code>graph TB\n    claim --&gt; getNonce\n    getNonce -- key --&gt; SMTVerifier[SMTVerifier]\n    0 -- value --&gt; SMTVerifier\n    claimMTP -- siblings --&gt; SMTVerifier\n    treeRoot -- root --&gt; SMTVerifier\n    1 -- enabled --&gt; SMTVerifier\n    zero1[1] -- fnc --&gt; SMTVerifier\n    noAux -- isOld0 --&gt; SMTVerifier\n    auxHi -- oldKey --&gt; SMTVerifier\n    auxHv -- oldValue --&gt; SMTVerifier\n\n    classDef inputStyle fill:#ecb3ff\n    class claim,claimMTP,treeRoot,noAux,auxHi,auxHv inputStyle\n\n    classDef circuitStyle fill:#b3ffd4,stroke-width:3px;  \n    class getNonce,SMTVerifier circuitStyle;</code></pre>"},{"location":"protocol/circuits/#checkchallengesignature","title":"checkChallengeSignature","text":"<p>This circuit checks if the challenge signature is correct. The public key for verification is extracted from the claim.</p> <pre><code>graph TB\n    claim --&gt; getPubKeyFromClaim\n    getPubKeyFromClaim -- Ax --&gt; EdDSAPoseidonVerifier\n    getPubKeyFromClaim -- Ay --&gt; EdDSAPoseidonVerifier\n    signatureS -- S --&gt; EdDSAPoseidonVerifier\n    signatureR8X -- R8X --&gt; EdDSAPoseidonVerifier\n    signatureR8Y -- R8Y --&gt; EdDSAPoseidonVerifier\n    challenge -- M --&gt; EdDSAPoseidonVerifier\n\n    classDef inputStyle fill:#ecb3ff\n    class claim,getPubKey,signatureS,signatureR8Y,signatureR8X,challenge inputStyle\n\n    classDef circuitStyle fill:#b3ffd4,stroke-width:3px\n    class getPubKeyFromClaim,EdDSAPoseidonVerifier circuitStyle</code></pre>"},{"location":"protocol/circuits/#verifyidenstatematchesroot","title":"verifyIdenStateMatchesRoot","text":"<p>The circuit calculates the identity state from the three Merkle tree roots and checks if it is equal to the expected state.</p> <pre><code>graph TB\n    claimsTreeRoot --&gt; calcRoot\n    revTreeRoot --&gt; calcRoot\n    rootsTreeRoot --&gt; calcRoot\n    calcRoot --&gt; equal[=]\n    expectedState ---&gt; equal\n\n    classDef inputStyle fill:#ecb3ff\n    class claimsTreeRoot,revTreeRoot,rootsTreeRoot,expectedState inputStyle\n\n    classDef circuitStyle fill:#b3ffd4,stroke-width:3px\n    class calcRoot,equal circuitStyle</code></pre>"},{"location":"protocol/circuits/#query","title":"Query","text":"<p>This circuit checks that an expression within an operator and its value are true.</p> <p>For example in=\"1\", operator=\"4\", value=[\"5\",\"2\",\"3\"] is true because \"4\" is \"not in\" operator and \"1\" is not in the [\"5\",\"2\",\"3\"] array.</p> <p>See all the operators in the circuit comments. The circuit graph is not represented here due to complexity.</p>"},{"location":"protocol/circuits/#functional-templates","title":"Functional Templates","text":"<p>These are the templates that the Iden3 system mostly uses to generate and verify proofs directly. A functional template may use other functional templates as its building blocks.</p>"},{"location":"protocol/circuits/#idownershipbysignature","title":"idOwnershipBySignature","text":"<p>This circuit checks the ownership of a specific identity in the following way:</p> <ol> <li>The claim with the public key should exist in the claims tree.</li> <li>The claim with the public key should not be revoked.</li> <li>The signature of a challenge should be valid.</li> <li>The state should be equal to \"expected\" from the blockchain.</li> </ol> <p>The above criteria enable a verifier to check that the challenge is signed by an identity, which state is timestamped on the blockchain and if it includes the non-revoked claim with the relevant public key.</p>"},{"location":"protocol/circuits/#credentialatomicquerymtp","title":"CredentialAtomicQueryMTP","text":"<p>This circuit checks that an issuer has issued a claim for identity and validates the ownership of that identity in the following manner:</p> <ol> <li>Checks the identity ownership by idOwnershipBySignature template</li> <li>Verifies the claim subject, the schema and the expiration time.</li> <li>Checks if the issuer claim exists in the issuer claims tree.</li> <li>Checks if the issuer claim is not revoked by an issuer.</li> <li>Checks if the issuer claim satisfies a query.</li> </ol>"},{"location":"protocol/circuits/#credentialatomicquerysig","title":"CredentialAtomicQuerySig","text":"<p>This circuit checks that an issuer has issued a claim for identity and validates ownership of that identity in the following manner:</p> <ol> <li>Checks the identity ownership by idOwnershipBySignature template.</li> <li>Verifies the claim subject, the schema and the expiration time</li> <li>Checks if the issuer claim exists in the issuer claims tree.</li> <li>Verifies the claim signature by the issuer.</li> <li>Verifies if the issuer state matches with the one from the blockchain as the public input.</li> <li>Checks if the issuer claim satisfies a query.</li> </ol>"},{"location":"protocol/claim-schema/","title":"Claim Schema","text":"<p>In order to reuse claims across different services is necessary to keep consistent data formatting. A Claim Schema encodes the structure of a particular claim by defining a type, the fields that must be included inside a claim, and a description for these fields.</p> <p>Schemas are described via JSON-LD documents. A claim issuer could reuse existing claim schemas or create new ones from scratch.</p>"},{"location":"protocol/claim-schema/#example-kycagecredential-schema","title":"Example: KYCAgeCredential Schema","text":"<ul> <li>Github Document</li> </ul> <pre><code>{\n  \"@context\": [\n    {\n      \"@version\": 1.1,\n      \"@protected\": true,\n      \"id\": \"@id\",\n      \"type\": \"@type\",\n      \"KYCAgeCredential\": {\n        \"@id\": \"https://raw.githubusercontent.com/iden3/claim-schema-vocab/main/schemas/json-ld/kyc-v4.jsonld#KYCAgeCredential\",\n        \"@context\": {\n          \"@version\": 1.1,\n          \"@protected\": true,\n          \"id\": \"@id\",\n          \"type\": \"@type\",\n          \"kyc-vocab\": \"https://github.com/iden3/claim-schema-vocab/blob/main/credentials/kyc.md#\",\n          \"xsd\": \"http://www.w3.org/2001/XMLSchema#\",\n          \"birthday\": {\n            \"@id\": \"kyc-vocab:birthday\",\n            \"@type\": \"xsd:integer\"\n          },\n          \"documentType\": {\n            \"@id\": \"kyc-vocab:documentType\",\n            \"@type\": \"xsd:integer\"\n          }\n        }\n      }\n    }\n  ]\n}\n</code></pre> <p>This document describes the schema for a claim of type <code>KYCAgeCredential</code>. The <code>@id</code> contains the unique url that contains the JSON-LD Document. The <code>kyc-vocab</code> contains a link to a url with a vocabulary description of the value types stored inside this claim, in this case <code>birthday</code> and <code>documentType</code>. The last part of the document contains a reference to the value types <code>birthday</code> and <code>documentType</code>. Their <code>@id</code> corresponds to their description in the kyc-vocab while the <code>@type</code> indicates where the data type of each field. In this case, <code>birthday</code> is an integer and <code>documentType</code> is also an integer.</p>"},{"location":"protocol/claim-schema/#schema-hash","title":"Schema Hash","text":"<p>The Schema Hash is a unique identifier for a Claim Schema. It is derived by hashing the string that represents unique identifier <code>@id</code> of the Claim Schema type. In the previous example, the hash pre-image is the string <code>https://raw.githubusercontent.com/iden3/claim-schema-vocab/main/schemas/json-ld/kyc-v4.jsonld#KYCAgeCredential</code>. ` For example, in the case of the Auth Claim the schema hash would be </p> <pre><code>var sHash core.SchemaHash\nh := Keccak256([]byte(\"https://raw.githubusercontent.com/iden3/claim-schema-vocab/main/schemas/json-ld/kyc-v4.jsonld#KYCAgeCredential\"))\ncopy(sHash[:], h[len(h)-16:])\nsHashHex, _ := sHash.MarshalText()\nfmt.Println(string(sHashHex))\n</code></pre>"},{"location":"protocol/claims-structure/","title":"Claim Data Structure","text":"<pre><code>graph TD\n     Hi--&gt;i0\n     Hi--&gt;i1\n     Hi--&gt;i2\n     Hi--&gt;i3\n\n     Hv--&gt;v0\n     Hv--&gt;v1\n     Hv--&gt;v2\n     Hv--&gt;v3\n\n     Ht--&gt;Hi\n     Ht--&gt;Hv</code></pre>"},{"location":"protocol/claims-structure/#common-structure","title":"Common Structure","text":"<p>A claim always contains a subject, that can be:</p> <ul> <li>Self: The claim says something about itself.  The subject is implicit, and it's the identity that makes claim.</li> <li>OtherIden: The claim says something about some other identity (identified by other's ID).</li> <li>Object: The claim says something about an object (identified by the object's ID).</li> </ul> <p>If the subject is Self -  identity, sections  i_1, v_1 can be empty. </p> <p>if the subject is NOT Self, the id(OtherIden) of the Identity/Object can be in the Index(i_1) or the Value(v_1) part of the claim.  This is encoded in a header bit.</p> <p>Other flags contained inside i_0 indicate: </p> <ul> <li>Whether the claim is expirable. In that case an expiration date must be added inside v_0</li> <li>Whether the claim is updatable.</li> <li>Whether the claim is merklized and where the root of the tree is located. It can be either inside i_2 or v_2</li> </ul> <pre><code>h_i = H(i_0, i_1, i_2, i_3)\nh_v = H(v_0, v_1, v_2, v_3)\nh_t = H(h_i, h_v)\n</code></pre> <pre><code>Index:\n i_0: [ 128  bits ] claim schema\n      [ 32 bits ] option flags\n          [3] Subject:\n            000: A.1 Self\n            001: invalid\n            010: A.2.i OtherIden Index\n            011: A.2.v OtherIden Value\n            100: B.i Object Index\n            101: B.v Object Value\n          [1] Expiration: bool\n          [1] Updatable: bool\n          [3] Merklized: data is merklized root is stored in the:\n            000: none\n            001: C.i Root Index (root located in i_2)\n            010: C.v Root Value (root located in v_2)\n          [24] 0\n      [ 32 bits ] version (optional?)\n      [ 61 bits ] 0 - reserved for future use\n i_1: [ 248 bits] identity (case b) (optional)\n      [  5 bits ] 0\n i_2: [ 253 bits] 0\n i_3: [ 253 bits] 0\nValue:\n v_0: [ 64 bits ]  revocation nonce\n      [ 64 bits ]  expiration date (optional)\n      [ 125 bits] 0 - reserved\n v_1: [ 248 bits] identity (case c) (optional)\n      [  5 bits ] 0\n v_2: [ 253 bits] 0\n v_3: [ 253 bits] 0\n</code></pre>"},{"location":"protocol/claims-structure/#claim-schema","title":"Claim Schema","text":"<p>Schemas define the type of data inside a claim link.</p> <p>Index slots i_2, i_3 and value slots v_2, v_3 are the data slots for user data.</p>"},{"location":"protocol/claims-structure/#index-vs-value","title":"Index vs Value","text":"<p>When to Use Index Slots and Value Slots?</p> <p>Claims are stored in the Merkle tree and the hash of the index slots ( hash(i_0, i_1, i_2, i_3) ) is unique for the whole tree. It means that you cannot have two claims with the same index inside the tree.</p> <p>As opposite to the index, the values slots could be the same for different claims if their indexes are different.</p>"},{"location":"protocol/main-circuits/","title":"Main Circuits","text":"<p>This iden3 circuits are the heart of the protocol. The main ones are: </p> <ul> <li><code>stateTransition.circom</code>, checks the execution of the identity state transition by taking the old identity state and the new identity state as inputs.</li> <li><code>authV2.circom</code>, checks that the prover is owner of an identity.</li> <li><code>credentialAtomicQueryMTPV2.circom</code>, checks that a claim issued to the prover (added to issuer's Claims Tree) satisfies a query set by the verifier.</li> <li><code>credentialAtomicQueryMTPV2OnChain.circom</code>, checks that a claim issued to the prover (added to issuer's Claims Tree) satisfies a query set by the verifier and the verifier is a smart contract.</li> <li><code>credentialAtomicQuerySigV2.circom</code> checks that a claim issued to the prover (signed by the Issuer) satisfies a query set by the verifier.</li> <li><code>credentialAtomicQuerySigV2OnChain.circom</code> checks that a claim issued to the prover (signed by the Issuer) satisfies a query set by the verifier and the verifier is a smart contract.</li> </ul> <p>You can find all the source code on Github - Iden3 Circuits. All the proving and verification keys necessary to use the circuits were generated after a Trusted Setup Ceremony. Details here:  Iden3 Protocol Phase2 Trusted Setup Ceremony</p>"},{"location":"protocol/main-circuits/#circuits-that-are-in-beta","title":"Circuits that are in beta","text":"<ul> <li><code>credentialAtomicQueryV3.circom</code> checks that a claim issued to the prover (signed by the Issuer or included to the Issuer's state) and satisfies a query set by the verifier.</li> <li><code>credentialAtomicQueryV3OnChain.circom</code> checks that a claim issued to the prover (signed by the Issuer or included to the Issuer's state) and satisfies a query set by the verifier (smart contract). Authentication check inside circuit can be disabled in case Ethereum-based identity authenticates with Ethereum account.</li> </ul>"},{"location":"protocol/main-circuits/#statetransition","title":"stateTransition","text":"<ul> <li> <p>Github</p> </li> <li> <p>Example of instantiation</p> </li> <li> <p>Circuit Specific Files (From Trusted Setup)</p> </li> </ul>"},{"location":"protocol/main-circuits/#instantiation-parameters","title":"Instantiation Parameters","text":"<ul> <li><code>idOwnershipLevels</code> Merkle tree depth level for Identity Trees (claims Tree, revocation Tree and roots Tree)</li> </ul>"},{"location":"protocol/main-circuits/#inputs","title":"Inputs","text":"Input Description Public or Private userID Prover's (Genesis) Identifier Public oldUserState Prover's Identity State (before transition) Public newUserState Prover's Identity State (after transition) Public isOldStateGenesis \"1\" indicates that the old state is genesis: it means that this is the first State Transition, otherwise \"0\" Public claimsTreeRoot Prover's Claims Tree Root Private authClaimMtp[idOwnershipLevels] Merkle Tree Proof of Auth Claim inside Prover's Claims tree Private authClaim[8] Prover's Auth Claim Private revTreeRoot Prover's Revocation Tree Root Private authClaimNonRevMtp[idOwnershipLevels] Merkle Tree Proof of non membership of Auth Claim inside Prover's Revocation Tree Private authClaimNonRevMtpNoAux Flag that indicates whether to check the auxiliary Node Private authClaimNonRevMtpAuxHv Auxiliary Node Value Private authClaimNonRevMtpAuxHi Auxiliary Node Index Private rootsTreeRoot Prover's Roots Tree Root Private signatureR8x Signature of the challenge (Rx point) Private signatureR8y Signature of the challenge (Ry point) Private signatureS Signature of the challenge (S point) Private newClaimsTreeRoot Claim Tree Root of the Prover after State Transtion is executed Private newAuthClaimMtp[IdOwnershipLevels]; Merkle Tree Proof of existance of the Prover's Auth Claim inside the Claims Tree after State Transtion is executed Private newRevTreeRoot Revocation Tree Root of the Prover after State Transtion is executed Private newRootsTreeRoot Roots Tree Root of the Prover after State Transtion is executed Private"},{"location":"protocol/main-circuits/#scope","title":"Scope","text":"<ul> <li>If oldState is genesis, verifies that userID is derived from the oldUserState (= genesis state). Performed using <code>cutId()</code>, <code>cutState()</code>and <code>isEqual()</code> templates</li> <li>newUserState is different than zero using <code>isZero()</code> comparator</li> <li>oldUserState and newUserState are different using <code>isEqual()</code></li> <li>Verifies user's identity ownership using <code>idOwnershipBySignature(IdOwnershipLevels)</code> template. The challenge signed by the user is <code>H(oldstate, newstate)</code> where <code>H</code> is a Poseidon hash function executed inside the <code>Poseidon(nInputs)</code> template</li> <li>Verifies that the auth claim exists in the <code>newClaimsTreeRoot</code> using <code>checkClaimExists(IdOwnershipLevels)</code> template</li> <li>Verifies that the new state (<code>newUserState</code>) matches the hash of the new claims tree root (<code>newClaimsTreeRoot</code>), revocation tree root (<code>newRevTreeRoot</code>) and roots tree root (<code>newRootsTreeRoot</code>) using <code>checkIdenStateMatchesRoots()</code></li> </ul>"},{"location":"protocol/main-circuits/#authv2","title":"authV2","text":"<ul> <li> <p>Github</p> </li> <li> <p>Example of instantiation</p> </li> <li> <p>Circuit Specific Files (From Trusted Setup)</p> </li> </ul>"},{"location":"protocol/main-circuits/#instantiation-parameters_1","title":"Instantiation Parameters","text":"<ul> <li><code>IdOwnershipLevels</code> Merkle tree depth levels for Identity Trees (claims Tree, revocation Tree and roots Tree)</li> <li><code>onChainLevels</code> Merkle tree depth of GIST stored on chain</li> </ul>"},{"location":"protocol/main-circuits/#inputs_1","title":"Inputs","text":"Input Description Public or Private genesisID genesis ID of the prover Private profileNonce Random number, stored by the user Private state Prover's Identity State Private claimsTreeRoot Prover's Claims Tree Root Private revTreeRoot Prover's Revocation Tree Root Private rootsTreeRoot Prover's Roots Tree Root Private authClaim[8] Prover's Auth Claim Private authClaimIncMtp[IdOwnershipLevels] Merkle Tree Proof of Auth Claim inclusion inside Prover's Claims tree Private authClaimNonRevMtp[IdOwnershipLevels] Merkle Tree Proof of non inclusion of Auth Claim Nonce inside Prover's Revocation Tree Private authClaimNonRevMtpNoAux Flag that indicates whether to check the auxiliary Node Private authClaimNonRevMtpAuxHi Auxiliary Node Index Private authClaimNonRevMtpAuxHv Auxiliary Node Value Private challenge Message to be signed by the Prover to prove control of an Identity Public challengeSignatureR8x Signature of the challenge (Rx point) Private challengeSignatureR8y Signature of the challenge (Ry point) Private challengeSignatureS Signature of the challenge (S point) Private gistRoot Root of the GIST stored on chain Private gistMtp[onChainLevels] Merkle Tree Proof of Inclusion of the user state inside the global state Private gistMtpAuxHi Auxiliary Node Index Private gistMtpAuxHv Auxiliary Node Value Private gistMtpNoAux Flag that indicates whether to check the auxiliary Node Private"},{"location":"protocol/main-circuits/#output","title":"Output","text":"Input Description Public or Private userID Identifier of the user, assigned to H(genesisID, nonce) if nonce != 0, assigned to genesisID if nonce = 0 Public"},{"location":"protocol/main-circuits/#scope_1","title":"Scope","text":"<ul> <li>Prover is owner of an identity by signing a message using <code>idOwnershipBySignature</code> template</li> <li>Checks that the user state is included in the GIST by using the SMTVerifier(onChainLevels)</li> <li>Calculate the <code>userID</code> as H(genesisID, nonce) if nonce != 0, assigned to genesisID if nonce = 0 as output it. This is the public Identity Profile of the user</li> </ul>"},{"location":"protocol/main-circuits/#credentialatomicquerymtpv2","title":"credentialAtomicQueryMTPV2","text":"<ul> <li> <p>Github</p> </li> <li> <p>Example of instantiation</p> </li> <li> <p>Circuit Specific Files (From Trusted Setup)</p> </li> </ul> <p>The circuit takes a query by a verifier and a claim owned by the prover and generate a proof that the claim satisfies the query. In particular, it checks that: </p> <ol> <li>Checks that the prover is owner of an identity by idOwnershipBySignature template</li> <li>Verifies that the identity is the subject of the claim</li> <li>Verifier that the claim is included in the issuer's claim tree</li> <li>Verifies that the claim schema matches the one in the query</li> <li>Verifies that the claim is not revoked by the issuer and is not expired</li> <li>Verifies that the query posed by the verifier is satisfied by the claim</li> </ol>"},{"location":"protocol/main-circuits/#credentialatomicquerymtpv2onchain","title":"credentialAtomicQueryMTPV2OnChain","text":"<ul> <li> <p>Github</p> </li> <li> <p>Example of instantiation</p> </li> <li> <p>Circuit Specific Files (From Trusted Setup)</p> </li> </ul> <p>This circuit should be used for smart contract verifiers. This circuits does all the checks that the credentialAtomicQueryMTPV2 circuit does, plus the following:</p> <ol> <li>Check that prover controls the identity the same way as the AuthV2 circuit checks it</li> <li>Calculates hash of the query inputs, like claimSchema, slotIndex, operator, claimPathKey, claimPathNotExists and values as an output for all the query related inputs. This reduces the number of public inputs and much cheaper for Smart Contracts to verify the proof.</li> </ol>"},{"location":"protocol/main-circuits/#credentialatomicquerysigv2","title":"credentialAtomicQuerySigV2","text":"<ul> <li> <p>Github</p> </li> <li> <p>Example of instantiation</p> </li> <li> <p>Circuit Specific Files (From Trusted Setup)</p> </li> </ul> <p>This circuit checks that an issuer has issued a claim for identity and validates ownership of that identity in the following manner:</p> <ol> <li>Checks that the prover is owner of an identity by idOwnershipBySignature template</li> <li>Verifies that the identity is the subject of the claim</li> <li>Verifier that the claim was signed by the issuer</li> <li>Verifies that the claim schema matches the one in the query</li> <li>Verifies that the claim is not revoked by the issuer and is not expired</li> <li>Verifies that the query posed by the verifier is satisfied by the claim</li> </ol>"},{"location":"protocol/main-circuits/#credentialatomicquerysigv2onchain","title":"credentialAtomicQuerySigV2OnChain","text":"<ul> <li> <p>Github</p> </li> <li> <p>Example of instantiation</p> </li> <li> <p>Circuit Specific Files (From Trusted Setup)</p> </li> </ul> <p>This circuit should be used for smart contract verifiers. This circuits does all the checks that the the credentialAtomicQuerySigV2 circuit does, plus the following:</p> <ol> <li>Check that prover controls the identity the same way as the AuthV2 circuit checks it</li> <li>Calculates hash of the query inputs, like claimSchema, slotIndex, operator, claimPathKey, claimPathNotExists and values as an output for all the query related inputs. This reduces the number of public inputs and much cheaper for Smart Contracts to verify the proof.</li> </ol>"},{"location":"protocol/main-circuits/#credentialatomicqueryv3","title":"credentialAtomicQueryV3","text":"<ul> <li> <p>Github</p> </li> <li> <p>Example of instantiation</p> </li> <li> <p>Circuit Specific Files (version 1.0.0-beta.0, NO Trusted Setup!)</p> </li> </ul> <p>This circuit checks that an issuer has issued a claim for identity and validates ownership of that identity in the following manner:</p> <ol> <li>Verifies that the identity or identity profile is the subject of the credential. </li> <li>Verifies that the schema in the core claim representation contains a hash of the credential type identifier.</li> <li>Verifies that the credential is not expired.</li> <li>Verifies that the credential is not revoked (in case the revocation check is not skipped).</li> <li>Verifies that the provided issuer state for non-revocation check is built from the provided tree roots (in case the revocation check is not skipped).</li> <li>Depending on the proof of the verifiable credential (Iden3SparseMerkleTreeProof or BJJSignature) determines the proof verification flow and the tree roots to verify.<ol> <li>Verification of BJJSignature Proof:<ol> <li>Verifies that AuthBJJ credential of the issuer (signing key) has a protocol-defined schema hash.</li> <li>Verifies that AuthBJJ credential of the issuer (signing key) is not revoked by the issuer.</li> <li>Verifies that the signature is valid and created with a private key corresponding to AuthBJJ credential of the issuer.</li> <li>Verifies that the core claim representation of AuthBJJ credential is included in the issuer state.</li> <li>Verifies that the provided issuer state for AuthBJJ issuance check is built from the provided tree roots.</li> </ol> </li> <li>Verification of Iden3SparseMerkleTreeProof:<ol> <li>Verifies that the core claim representation of the user credential is included in the issuer state.</li> <li>Verifies that the provided issuer state for issuance check is built from the provided tree roots.</li> </ol> </li> </ol> </li> <li>Verifies query:<ol> <li>Verifies that the credential field is a part of the merklized root from core claim representation (in case schema is for merklized credential).</li> <li>Verifies that the credential field is located at the expected data slot of core claim representation (in case schema is for non-merklized credential).</li> <li>Verifies that credential data satisfies the query condition. </li> </ol> </li> <li>Calculates nullifier in case nullifier session id and verifierID are set and credential has been issued to the user profile.</li> <li>Outputs the field value in case selective disclosure is requested.</li> <li>Generates user profile in case profile nonce is set.</li> <li>Calculates link id in case links session id is set.</li> </ol>"},{"location":"protocol/main-circuits/#credentialatomicqueryv3onchain","title":"credentialAtomicQueryV3Onchain","text":"<ul> <li> <p>Github</p> </li> <li> <p>Example of instantiation</p> </li> <li> <p>Circuit Specific Files (version 1.0.0-beta.0, NO Trusted Setup!)</p> </li> </ul> <p>This circuit should be used for smart contract verifiers. This circuit does all the checks that the credentialAtomicQueryV3 circuit does, plus the following:</p> <ol> <li>Checks that the prover controls the identity in the same way AuthV2 circuit checks it if auth is enabled.</li> <li>Verifies credential query in the same way as credentialAtomicQueryV3 does.</li> <li>Calculates hash of the query inputs, like claimSchema, slotIndex, operator, claimPathKey, claimPathNotExists, and values as an output for all the query-related inputs.    This reduces the number of public inputs and makes it much cheaper for Smart Contracts to verify the proof.</li> </ol>"},{"location":"protocol/non-merklized/","title":"Non-merklized credentials","text":""},{"location":"protocol/non-merklized/#motivation","title":"Motivation","text":"<p>While Iden3 protocol allows to \"merklize\" the whole JSON-LD document (transform the document into key-value pairs and put them into a sparse merkle tree for later proving of credential field value in the tree), which removes limits on amount and structure of the credential data, there's still a need to issue a core claim with the data itself. This is particularly useful for onchain issuers, which can\u2019t work with json-ld schemas in smart contracts (for many reasons), and also for use cases when the actual data must be saved for cheaper access inside circuits (e.g. Auth BJJ credential public key representation).</p> <p>Core Concept</p> <p>Non-merklized credentials now can be created relying on JSON-LD schemas.</p> <p>Example of such context: <code>https://schema.iden3.io/core/jsonld/auth.jsonld</code></p> <pre><code>{\n  \"@context\": [{\n    \"@version\": 1.1,\n    \"@protected\": true,\n    \"id\": \"@id\",\n    \"type\": \"@type\",\n    \"AuthBJJCredential\": {\n      \"@id\": \"https://schema.iden3.io/core/jsonld/auth.jsonld#AuthBJJCredential\",\n      \"@context\": {\n        \"@version\": 1.1,\n        \"@protected\": true,\n        \"id\": \"@id\",\n        \"type\": \"@type\",\n        \"iden3_serialization\": \"iden3:v1:slotIndexA=x&amp;slotIndexB=y\",\n        \"xsd\": \"http://www.w3.org/2001/XMLSchema#\",\n        \"auth-vocab\": \"https://schema.iden3.io/core/vocab/auth.md#\",\n        \"x\": {\n          \"@id\": \"auth-vocab:x\",\n          \"@type\": \"xsd:positiveInteger\"\n        },\n        \"y\": {\n          \"@id\": \"auth-vocab:y\",\n          \"@type\": \"xsd:positiveInteger\"\n        }\n      }\n    }\n  }]\n}\n</code></pre> <p>Schema is defined as a schema for non-merklized credentials by utilizing <code>iden3_serialization</code> attribute.</p> <p>It contains a map string represented mapping, where:</p> <p><code>iden3:v1</code> - version of protocol serialization, constant.</p> <p><code>slotIndexA=x</code>  slotIndexA is index data slot  A with index 2 for path to field  <code>x</code> in credential</p> <p><code>slotIndexB=y</code>  slotIndexB is index data slot B  with index 3 for path to field <code>y</code> in credential</p> <p>other possible values:</p> <p><code>slotValueA</code>  slotIndexB is value data slot  with index 6</p> <p><code>slotValueB</code>  slotValueB is value data slot  with index 7</p> <p>When a user creates a schema, he should choose the slot to put the field.</p> <p>Nested structures are supported and path is created using concatenation with <code>.</code> e.g for birthday field in the Index Data Slot A mapping entry looks like that:</p> <p><code>\"iden3:v1:slotIndexA=passportInfo.birthday\"</code></p> <pre><code>{\n  \"@context\": [\n    {\n      \"@version\": 1.1,\n      \"@protected\": true,\n      \"id\": \"@id\",\n      \"type\": \"@type\",\n      \"Passport\": {\n        \"@id\": \"uuid:urn:229a9afc-4aad-48e4-b113-bf2ca6f3a98f\",\n        \"@context\": {\n          \"@version\": 1.1,\n          \"@protected\": true,\n          \"id\": \"@id\",\n          \"type\": \"@type\",\n          \"kyc-vocab\": \"https://github.com/iden3/claim-schema-vocab/blob/main/credentials/kyc.md#\",\n          \"xsd\": \"http://www.w3.org/2001/XMLSchema#\",\n          \"passportInfo\": {\n            \"@id\": \"kyc-vocab:passportInfo\",\n            \"@context\": {\n              \"@version\": 1.1,\n              \"@protected\": true,\n              \"kyc-vocab\": \"https://github.com/iden3/claim-schema-vocab/blob/main/credentials/kyc.md#\",\n              \"xsd\": \"http://www.w3.org/2001/XMLSchema#\",\n              \"id\": \"@id\",\n              \"type\": \"@type\",\n              \"birthday\": {\n                \"@type\": \"xsd:integer\",\n                \"@id\": \"kyc-vocab:birthday\"\n              }\n            }\n          }\n        }\n      }\n    }\n  ]\n}\n</code></pre> <p>Important:</p> <ol> <li>Fields in index slots make influence on the uniqueness of the claim in the clams tree of issuer, data in the value slots - don\u2019t.</li> <li>Data Slots number is 4, so there is a restriction to have only 4 fields for non-merklized credentials.</li> </ol> <p>Meanwhile <code>@type</code> filed for each field must contain one of the supported primitive types, so value can be written according to the data type.</p> <p>List of supported data types:</p> <pre><code>XSD namespace {\n  Boolean = 'http://www.w3.org/2001/XMLSchema#boolean',\n  Integer = 'http://www.w3.org/2001/XMLSchema#integer',\n  NonNegativeInteger = 'http://www.w3.org/2001/XMLSchema#nonNegativeInteger',\n  NonPositiveInteger = 'http://www.w3.org/2001/XMLSchema#nonPositiveInteger',\n  NegativeInteger = 'http://www.w3.org/2001/XMLSchema#negativeInteger',\n  PositiveInteger = 'http://www.w3.org/2001/XMLSchema#positiveInteger',\n  DateTime = 'http://www.w3.org/2001/XMLSchema#dateTime',\n  Double = 'http://www.w3.org/2001/XMLSchema#double'\n}\n</code></pre> <p>Libraries that support non-merklized credentials: https://github.com/iden3/go-schema-processor/releases/tag/v2.0.1 https://github.com/0xPolygonID/js-sdk/releases/tag/v1.1.0</p> <p>To create non-merklized credential in go-schema-processor / JS-sdk  merklized Root Position must be set to None (default value) and ld context must contain <code>iden3_serialization</code> attribute.</p> <pre><code>processor.CoreClaimOptions{\n          ..,\n            MerklizedRootPosition: verifiable.CredentialMerklizedRootPositionNone,\n      ...\n        }\n</code></pre> <p>If context contains serialization attribute but MerklizedRootPosition is set to Index / Value error will be thrown.</p> <p>In case context doesn\u2019t contain serialization attribute and MerklizedRootPosition is set to Index / Value. Merkle root will be written to corresponding position. If the MerklizedRootPosition is set to None Merkle root will be written to Index.</p>"},{"location":"protocol/querylanguage/","title":"ZK Query Language","text":""},{"location":"protocol/querylanguage/#goal-of-the-zk-query-language","title":"Goal of the ZK Query Language","text":"<p>The initial idea is to have a generic circuit with the possibility to do a verification based on user-claims. As circuit setup is not a trivial task and especially, the trusted setup is a challenging thing for regular developers, we have to provide a simple generic query language based on the generic prebuilt circuits.</p> <p>The use of the Query Language should not be limited to specific atomic circuits; it must be extendable to other circuits too.</p>"},{"location":"protocol/querylanguage/#syntax","title":"Syntax","text":"<p>The first version is set to support only these operations: &gt;, &lt;,  =, in and notin. Later on, this list could be extended.</p> <p>Comparison Operations</p> <ul> <li>&gt; greater than</li> <li>&lt;  less than</li> <li>=  equal to</li> <li>notin - matches none of the values</li> <li>in - matches one of the values</li> </ul> <p>We have to use some syntax instead of raw signs as it will be inconvenient to use signs such as &lt;, &gt;, and = in JS. For example, $eq can be used instead of = , $gt can be used instead of &gt;,and so on. </p> <p>Simple Operations</p> <pre><code>{ &lt;field&gt;: { $eq: &lt;value&gt; } } - equal \n{ &lt;field&gt;: { $gt: &lt;value&gt; } } - greater than\n{ &lt;field&gt;: { $lt: &lt;value&gt; } } - less than\n{ &lt;field&gt;: { $nin: [&lt;value&gt;,&lt;value&gt;] } }\n{ &lt;field&gt;: { $in: [&lt;value&gt;,&lt;value&gt;] } }\n</code></pre> <p>For atomic claims, these operations could cover a lot of use-cases.</p>"},{"location":"protocol/querylanguage/#atomic-circuit","title":"Atomic Circuit","text":"<p>The first implementation will cover only simple atomic verification of one field. It means that we will do query requests only to one data field. But we have to do all the required service verifications too such as check ownership, revocation, expiration, etc. We also need to include some additional attributes specific to the identity:</p> <ul> <li>Schemas List</li> <li>List of Trusted Issuers</li> <li>Challenge</li> </ul> <p>Example: A simple query</p> <pre><code>{\n  \"circuit_id\": \"attrQuery\",\n  \"type\": \"zkp\",\n  \"rules\": {\n    \"query\": [\n      {\n        \"allowedIssuers\": [\n          \"115zTGHKvFeFLPu3vF9Wx2gBqnxGnzvTpmkHPM2LCe\"\n        ],\n        \"schema\": [\n          {\n            \"url\": \"https://raw.githubusercontent.com/iden3/claim-schema-vocab/main/schemas/json-ld/kyc-v2.json-ld\",\n            \"type\": \"KYCAgeCredential\"\n          }\n        ],\n        \"challenge\": 12345678,\n        \"req\": {\n          \"birthdate\": {\n            \"$lt\": 20000101\n          }\n        }\n      }\n    ]\n  }\n}\n</code></pre> <p>where:</p> <ul> <li>allowedIssuers: A list of issuers whom the verifier trusts.</li> <li>schema: A list of schemas that claims can use for proof generation.</li> <li>challenge: Used to verify that the provided proof belongs to the existing user session.</li> <li>req: A query request to the circuit.</li> </ul> <p>Example: Multiple requests in one query (WIP)</p> <pre><code>{\n  \"circuit_id\": \"atomicQueryMTP\",\n  \"type\": \"zkp\",\n  \"rules\": {\n    \"query\": [\n      {\n        \"allowedIssuers\": [\n          \"115zTGHKvFeFLPu3vF9Wx2gBqnxGnzvTpmkHPM2LCe\"\n        ],\n        \"schema\": [\n          {\n            \"url\": \"https://raw.githubusercontent.com/iden3/claim-schema-vocab/main/schemas/json-ld/kyc-v2.json-ld\",\n            \"type\": \"KYCAgeCredential\"\n          }\n        ],\n        \"challenge\": 12345678,\n        \"req\": {\n          \"birthdate\": {\n            \"$lt\": 20000101\n          }\n        }\n      },\n      {\n        \"allowedIssuers\": [\n          \"115zTGHKvFeFLPu3vF9Wx2gBqnxGnzvTpmkHPM2LCe\"\n        ],\n        \"schema\": [\n          {\n            \"type\": \"KYCCountryOfResidenceCredential\",\n            \"url\": \"ipfs://QmP8NrKqoBKjmKwMsC8pwBCBxXR2PhwSepwXx31gnJxAbP\"\n          }\n        ],\n        \"challenge\": 12345678,\n        \"req\": {\n          \"country\": {\n            \"$nin\": [\n              840,\n              123\n            ]\n          }\n        }\n      }\n    ]\n  }\n}\n</code></pre> <p>A query circuit should accept query requests and perform the following mandatory verifications.</p> <p>Mandatory Verifications </p> <ul> <li>Verifying the claim Id ownership (proof is generated by identity, which is the subject of the claim).</li> <li>Verifying that the claim is not revoked.</li> <li>Verifying that the claim is not expired.</li> <li>Verifying that the identity key is not revoked.</li> </ul> <p>Query</p> <ul> <li>Apply query request</li> </ul> <p>Optional</p> <ul> <li>Check schema.</li> <li>Check the issuer of the claim.</li> </ul> <p>In some cases, schema and issuer are not important and therefore, we can have the possibility to omit these fields.</p> <p>List of Signals for Circuit</p> <p>Id Ownership Signals:</p> <pre><code>signal input id;\nsignal input hoIdenState;\n\nsignal input hoClaimsTreeRoot;\nsignal input authClaimMtp[IdOwnershipLevels];\nsignal input authClaim[8];\n\nsignal input hoRevTreeRoot;\nsignal input authClaimNonRevMtp[IdOwnershipLevels];\nsignal input authClaimNonRevMtpNoAux;\nsignal input authClaimNonRevMtpAuxHi;\nsignal input authClaimNonRevMtpAuxHv;\n\nsignal input hoRootsTreeRoot;\n\nsignal input challenge;\nsignal input challengeSignatureR8x;\nsignal input challengeSignatureR8y;\nsignal input challengeSignatureS;\n</code></pre> <p>Claim Signals:</p> <pre><code>signal input claimSchema;\nsignal input claim[8];\nsignal input claimIssuanceMtp[IssuerLevels];\nsignal input claimIssuanceClaimsTreeRoot;\nsignal input claimIssuanceRevTreeRoot;\nsignal input claimIssuanceRootsTreeRoot;\nsignal input claimIssuanceIdenState;\nsignal input issuerID;\n</code></pre> <p>Verify Claim Revocation Statuses:</p> <pre><code>signal input claimNonRevMtp[IssuerLevels];\nsignal input claimNonRevMtpNoAux;\nsignal input claimNonRevMtpAuxHi;\nsignal input claimNonRevMtpAuxHv;\nsignal input claimNonRevIssuerClaimsTreeRoot;\nsignal input claimNonRevIssuerRevTreeRoot;\nsignal input claimNonRevIssuerRootsTreeRoot;\nsignal input claimNonRevIssuerState;\n</code></pre> <p>Query Requests:</p> <pre><code>signal input slotIndex; // index of field slot in the claim\nsignal input value[valueArraySize]; // value for check\nsignal input operator; // &gt;,&lt;, =,in, notin operations of CQL\n</code></pre> <p>Public Inputs:</p> <pre><code>challenge,\nid,\nhoIdenState,\nissuerID,\nclaimIssuanceIdenState,\nclaimSchema,\nslotIndex,\noperator,\nvalue,\ntimestamp\n</code></pre>"},{"location":"protocol/querylanguage/#proof-request-workflow","title":"Proof Request Workflow","text":"<p>Verifier (User)</p> <ol> <li>The verifier prepares a proof by requesting a query to the atomic circuit. Request:</li> </ol> <pre><code>{\n  \"circuit_id\": \"attrQuery\",\n  \"type\": \"zkp\",\n  \"rules\": {\n    \"query\": [\n      {\n        \"allowedIssuers\": [\n          \"115zTGHKvFeFLPu3vF9Wx2gBqnxGnzvTpmkHPM2LCe\"\n        ],\n        \"schema\": [\n          {\n            \"url\": \"https://raw.githubusercontent.com/iden3/claim-schema-vocab/main/schemas/json-ld/kyc-v2.json-ld\",\n            \"type\": \"KYCAgeCredential\"\n          }\n        ],\n        \"challenge\": 12345678,\n        \"req\": {\n          \"birthdate\": {\n            \"$lt\": 20000101\n          }\n        }\n      }\n    ]\n  }\n}\n</code></pre> <ol> <li>The user parses a proof request and performs the necessary checks:</li> <li>The circuit is known.</li> <li>The schema is known.</li> <li>Claims by the specified issuer persist in the wallet.</li> <li>Get the issuer public state for key non-revocation proof.</li> <li>Prepare inputs for the circuit:<ol> <li>Prepare ownership / claim / issuer / query inputs.</li> <li>Use schema to resolve field position in the claim.</li> </ol> </li> <li>Generate ZK proof.</li> <li>Create proof-sharing response protocol message and send it to the verifier.</li> </ol> <p>Flow Diagram:</p> <p></p>"},{"location":"protocol/querylanguage/#next-steps-future-enhancements","title":"Next Steps (future enhancements)","text":"<ol> <li>Make it possible to query multiple fields from the same schema, still, it is limited to four available slots, two indexes, and two values. With this combination, we can cover the more advanced use cases.</li> <li>Support more query operations.</li> <li>Fields combinations.</li> <li>Claim combinations.</li> <li>Represent JSON-LD document as a tree and store root as a claim. Extend verifications to this new schema. Do an atomic query verification.</li> <li>Extended query schema with multifield verifications from JSON-LD.</li> </ol>"},{"location":"protocol/spec/","title":"Iden3 Protocol Specifications (Version 0)","text":"<p>These specifications are under development and are being updated regularly. Consider it as a work-in-progress.</p>"},{"location":"protocol/spec/#basis","title":"Basis","text":""},{"location":"protocol/spec/#glossary","title":"Glossary","text":"<ul> <li>Issuer: An actor who makes a claim.</li> <li>Holder: An actor who receives a claim.</li> <li>Verifier: An actor who verifies if the content of a claim is issued by a specific identity and held by another specific identity.</li> <li>Credential: Data that is needed to prove that a claim is issued by a specific identity and held by another specific identity. This data is composed of a claim and a proof.</li> </ul>"},{"location":"protocol/spec/#merkle-tree","title":"Merkle Tree","text":"<p>A Merkle tree (MT) or a hash tree is a cryptographically verifiable data structure where every \"leaf\" node of the tree contains the cryptographic hash of a data block, and every \"non-leaf\" node contains the cryptographic hash of its child nodes.</p> <p>The MTs used in the protocol have a few particularities:</p> <ul> <li>Binary: Each node can only have two children.</li> <li>Sparse and Deterministic: The contained data is indexed, and each data block is placed at the leaf that corresponds to that data block's index, so insert order doesn't influence the final Merkle tree Root. This also means that some nodes are empty.</li> <li>ZK-friendly: The used hash function, poseidon, plays well with the zero-knowledge proofs (ZKP) used in different parts of the protocol.</li> </ul> <p>In order to ensure that these particularities are respected and to have a history of all the changes that occurred on different trees (without revealing the actual content stored in the leaves), the root of each MT is indirectly stored on the blockchain. The EVM-based blockchains are chosen for this purpose.</p> <p>The <code>Merkle tree</code> specification is defined in this document. In future, the MT implementation could be changed.</p>"},{"location":"protocol/spec/#zero-knowledge-proof-zkp","title":"Zero-knowledge Proof (ZKP)","text":"<p>In cryptography, a zero-knowledge proof is a method by which one party (the prover) can prove to a second party (the verifier) that the prover knows a value x (that fulfills some constraints), without revealing any other information apart from the fact that s/he knows the value x.</p> <p>The technologies that implement these techniques are evolving rapidly. As of now, the protocol uses zkSNARKs Groth16, but in future, the ZK protocol could be changed. zkSNARK stands for \"Zero-knowledge Succinct Non-interactive Argument of Knowledge\", and has the following properties:</p> <ul> <li>Non-interactive: With a single message (credential) from the prover, the verifier can verify the proof.  This is good because it allows sending proofs to a smart contract that can verify these proofs immediately.</li> <li>Efficient Verification: It is computationally efficient to verify proofs, both in terms of the size and the operations. This is apt for the protocol because verification happens on the blockchain with its inherent costs.</li> <li>Heavy Proof Generation: Generating a proof is computationally very expensive and can be time-consuming even with powerful hardware.</li> <li>Setup: A pre-existing setup between the prover and the verifier is required for the construction of zkSNARKs. In order to ensure that the verifier cannot cheat, one has to be sure that the keys used for the setup have been destroyed. There are protocols to ensure that, resulting in a \"trusted setup\".</li> </ul> <p>Read more technical information about zkSNARKs in this article by Vitalik Buterin.</p>"},{"location":"protocol/spec/#claims","title":"Claims","text":""},{"location":"protocol/spec/#definition","title":"Definition","text":"<p>A claim is a statement made by one identity about another identity or about itself. Each claim is composed of two parts: the index part and the value part. Claims are stored on the leaves of an MT. The index is hashed and is used to determine the leaf position where the value of the claim will be stored. A special transition validation function can be used to restrict how leaves are stored on the Merkle tree, i.e. make the MT append-only, (leaves can only be added and cannot be updated or deleted).</p>"},{"location":"protocol/spec/#properties","title":"Properties","text":"<ul> <li>It is impossible to generate proof of a statement on behalf of an identity without its consent.</li> <li>Claims can be revoked.</li> <li>Claims can be updated by creating new versions. When a claim is revoked, no further versions can be made. Claims can be set to be updatable or not with a flag (See Claim Structure).</li> </ul> <pre><code>graph LR\n    revoked(Revoked claim)\n    no-claim--&gt;v0\n    v0--&gt;v1\n    v1-.-&gt;vN\n    vN--&gt;vN1\n    vN1--&gt;revoked\n\n    no-claim(No claim)\n    v0(Claim v0)\n    v1(Claim v1)\n    vN(Claim vN)\n    vN1(Claim vN+1)</code></pre> <ul> <li>Claims can be verified. This means that it is possible to demonstrate cryptographically that a given claim is:<ul> <li>Issued by a specific identity.</li> <li>Not revoked.</li> <li>Is of the last version of that claim if it is updatable.</li> </ul> </li> <li>There are two types of claims regarding destination:<ul> <li>Claims about identity's own properties. Example: Operational Key, Ethereum Address, etc.</li> <li>Claims about another identity's properties:<ul> <li>(Another) Identity has a Property: Directional relation between an identity and a property (See Claim Structure: identity stored in hIndex, i_1).</li> <li>Property is Owned by (Another) Identity: Directional relation between a property and an identity (See Claim Structure: identity stored in hValue, v_1).</li> </ul> </li> </ul> </li> </ul> <p>Note</p> <p>Some of these properties are only guaranteed by a transition validation function (explained above in this document).</p>"},{"location":"protocol/spec/#structure","title":"Structure","text":"<pre><code>h_i = H(i_0, i_1, i_2, i_3)\nh_v = H(v_0, v_1, v_2, v_3)\nh_t = H(h_i, h_v)\n</code></pre> <pre><code>graph TD\n    Hi--&gt;i0\n    Hi--&gt;i1\n    Hi--&gt;i2\n    Hi--&gt;i3\n\n    Hv--&gt;v0\n    Hv--&gt;v1\n    Hv--&gt;v2\n    Hv--&gt;v3\n\n    Ht--&gt;Hi\n    Ht--&gt;Hv</code></pre> <pre><code>Index:\n i_0: [ 128  bits ] claim schema\n      [ 32 bits ] option flags\n          [3] Subject:\n            000: A.1 Self\n            001: invalid\n            010: A.2.i OtherIden Index\n            011: A.2.v OtherIden Value\n            100: B.i Object Index\n            101: B.v Object Value\n          [1] Expiration: bool\n          [1] Updatable: bool\n          [3] Merklized: data is merklized root is stored in the:\n            000: none\n            001: C.i Root Index (root located in i_2)\n            010: C.v Root Value (root located in v_2)\n          [24] 0\n      [ 32 bits ] version (optional?)\n      [ 61 bits ] 0 - reserved for future use\n i_1: [ 248 bits] identity (case b) (optional)\n      [  5 bits ] 0\n i_2: [ 253 bits] 0\n i_3: [ 253 bits] 0\nValue:\n v_0: [ 64 bits ]  revocation nonce\n      [ 64 bits ]  expiration date (optional)\n      [ 125 bits] 0 - reserved\n v_1: [ 248 bits] identity (case c) (optional)\n      [  5 bits ] 0\n v_2: [ 253 bits] 0\n v_3: [ 253 bits] 0\n</code></pre>"},{"location":"protocol/spec/#reliability-of-a-claim-content","title":"Reliability of a Claim Content","text":"<p>The correctness of what is said in a claim is not verifiable by a protocol since every identity is free to claim whatever it wants. Since it is possible to know which identity issued which claim, the trust/reputation that the issuer has can affect its credibility.</p> <p>However, the protocol can guarantee exclusivity: there cannot be two claims with the same index. So it is impossible that an identity claims that a property (index part of the claim) is linked to two different identities (value part of the claim) at the same time.</p>"},{"location":"protocol/spec/#keys","title":"Keys","text":"<p>Keys are cryptographic elements that can be used to sign data. In a protocol, keys are used to authenticate certain interactions.</p> <p>These keys require the authorization of the identity (who owns these keys). This is done by adding a claim with a specific schema, linking the key(s) with the identity. </p> <p>This way, each time that a key is used for signing, the identity can (and must) prove the ownership of that key and the fact that the key is not revoked.</p>"},{"location":"protocol/spec/#types-of-keys","title":"Types of Keys","text":"<ul> <li>Baby Jubjub: Used for authentication. This type of key is designed to be efficient while working with zkSNARKs.   The <code>Baby Jubjub Elliptic Curve</code> specification is defined in this document.</li> </ul>"},{"location":"protocol/spec/#identity","title":"Identity","text":""},{"location":"protocol/spec/#definition_1","title":"Definition","text":"<p>An <code>identity</code> is characterized by the claims that the identity has issued, and the claims that the identity has received from other identities. In other words, an identity is built by what the identity has said, and what others have said about the identity.</p> <p>Each claim that an identity issues can be cryptographically proved and verified, ensuring that the claim existed under identity at a certain timestamp.</p> <pre><code>graph TD\n    Root--&gt;A\n    Root--&gt;B\n\n    A--&gt;C\n    A--&gt;D\n    B--&gt;E\n    B--&gt;F\n\n    C--&gt;G\n    C--&gt;H\n    D--&gt;I\n    D--&gt;J\n    E--&gt;K\n    E--&gt;L\n    F--&gt;M\n    F--&gt;N\n\n    G[\"claim\"]\n    H[\"claim\"]\n    I[\"claim\"]\n    J[\"claim\"]\n    K[\"claim\"]\n    L[\"claim\"]\n    M[\"claim\"]\n    N[\"claim\"]</code></pre> <p>To accomplish this (and other properties covered in this document), identities are built by Merkle trees, where the claims are placed as the leaves, and the <code>Root</code> is published (indirectly through the identity state) on the blockchain. With this construction, the identities can issue, update, and revoke claims.</p> <p>The protocol construction is designed to enable zero-knowledge features. It means that the identities have the ability to prove the ownership of the properties of the claims in issued and received claims and verify that a particular claim is not revoked.</p>"},{"location":"protocol/spec/#genesis-id","title":"Genesis ID","text":""},{"location":"protocol/spec/#description","title":"Description","text":"<p>Each identity has a unique <code>identifier</code> that is determined by the initial identity state (hash of its Merkle Tree Roots). This identifier is called <code>Genesis ID</code>, under which the initial claims are placed (those that are contained in the initial state of the identity).</p> <p>For the initial implementation of the protocol, the Genesis Claims Tree will contain at least a claim of authorization of the Operational Key that allows operation in the name of identity.   </p> <p>While an identity does not add, update or revoke claims after the Genesis State, its identity state does not need to be published on the blockchain, and the <code>Genesis Claims</code> can be verified directly against the <code>Genesis ID</code>. This is because the Genesis ID is built by the Merkle Root that holds those claims.</p> <p>Note</p> <p>The Genesis ID is calculated with the Identity State as a hash of the Genesis Claims Tree Root, an empty Revocation Tree Root and an empty Roots Tree Root.</p>"},{"location":"protocol/spec/#identifier-format","title":"Identifier Format","text":"<p>An Identifier is determined by its identity type and the <code>Genesis Identity State</code> (also called the <code>Genesis ID</code>). This is built by creating a Merkle Tree that holds the initial state claims, calculating its root, and hashing it together with an empty Revocation Tree Root &amp; an empty Roots Tree Root. Then we take the first 27 bytes of this result and add to it 2 bytes at the beginning (to specify the identity type), and 2 bytes at the end (for checksum).Thus, in total, an identifier is a byte array of 31 bytes, encoded in base58.</p> <p>An identity type specifies the specifications that an identity follows (such as the hash function used by the identity). In this way, when the hash function changes, the identifiers of the identities will also change, allowing us to identify the type of identity.</p> <p>Identifier Structure:</p> <ul> <li><code>ID</code> (genesis): Base58 [ <code>type</code> | <code>genesis_state</code> | <code>checksum</code> ]<ul> <li><code>type</code>: 2 bytes specifying the type</li> <li><code>genesis_state</code>: First 27 bytes from the identity state (using the Genesis Claim Merkle tree)</li> <li><code>checksum</code>: Addition (with overflow) of all the ID bytes Little Endian 16 bits ( [ <code>type</code> | <code>genesis_state</code> ] )</li> </ul> </li> </ul>"},{"location":"protocol/spec/#identity-state","title":"Identity State","text":"<p>The identity states are published on the blockchain under the identifier, anchoring the state of the identity with the timestamp when it is published. In this way, the claims of the identity can be proved against the anchored identity state at a certain timestamp. To transition from one state to the other, identities follow the transition functions.</p> <p>The identity states can be published on the blockchain in one of the two ways: directly performing the transaction to publish the root or indirectly using a Relay. </p> <p>The <code>Genesis State</code> is the initial state of any identity, and does not need to be published on the blockchain, as the claims under it can be verified against the identifier itself (that contains that identity state).</p> <p></p>"},{"location":"protocol/spec/#identity-state-transition-function","title":"Identity State Transition Function","text":"<p>The <code>ITF</code> (Identity State Transition Function) is verified each time a state is updated. This ensures that the identity follows the protocol while updating.</p> <p>An Identity Merkle tree is a sparse binary tree that allows only the addition of the leaves (no edition or deletion). Adding new claims, updating them through versions and revoking need to be done according to the <code>ITF</code>. To ensure this, we use zero-knowledge proofs in a way that when an identity is publishing a new state to the smart contract, it also sends a zero-knowledge proof (<code>\u03c0</code>), proving that the <code>\u03d5</code> is satisfied following the <code>ITF</code>. In this way, all the identity states published on the blockchain are validated to be following the protocol.</p> <p>Note</p> <p>In the initial version of the implementation, there will be no checks to verify that the trees are append-only in the smart contract. This is due to the fact that complex computations are required to generate the ZK proofs for multiple claim additions, (a requirement for scalability).</p> <p>The full circuit can be found here: https://github.com/iden3/circuits/blob/master/circuits/stateTransition.circom</p>"},{"location":"protocol/spec/#identity-profiles-new","title":"Identity Profiles (NEW)","text":"<p>Identity Profiles allow users to hide their <code>Genesis ID</code> during interactions. Instead, users will be identified by their <code>Identity Profile</code>.</p> <p>An Identity Profile is generated from the <code>GenesisID</code> and hashing it with a (random) nonce. </p> <p><code>Identity Profile</code> has the same structure as the <code>Genesis ID</code>. It is a byte array of 31 bytes, encoded in base58.</p> <p>[ <code>IDtype</code> (2 bytes) | <code>profile_state</code> (27 bytes) | <code>checksum</code> (2 bytes) ]</p> <ul> <li><code>IDtype</code> :  inherited type from <code>Genesis ID</code></li> <li><code>profile_state</code> : First 27 bytes from the poseidonHash(<code>Genesis ID</code>, <code>profile_nonce</code>), where <code>profile_nonce</code> is any random number</li> <li><code>checksum</code> Addition (with overflow) of all the ID bytes Little Endian 16 bits ([\u00a0<code>typeID</code>| <code>profile_state</code>])</li> </ul> <p>Identity Profiles are irreversible and indistinguishable:</p> <ul> <li>Irreversible, thanks to the properties of the underlying hash function, meaning that it is impossible to retrieve the <code>Genesis ID</code> from an <code>Identity Profile</code>, unless you know the nonce.  </li> <li>indistinguishable, the data format of Identity Profiles is the same as Genesis IDs. It follows that an external party cannot tell if an identity is using its Genesis ID or one of its many Identity Profiles.</li> </ul> <p>An Identity can receive claims to a specific Identity Profile. An Identity Profile keeps all the properties of Genesis IDs while adding:</p> <ul> <li>Anti-track</li> </ul> <p>Since users are no longer consistently identified with the same identifier in their interactions across different platforms, it becomes harder to track the action of a single user. Even if platforms collude. Even more, the user can interact with the same platform using different Identity Profiles, making it impossible to track the user across different interactions inside the same platform.</p> <ul> <li>Faculty to decide which profile to show</li> </ul> <p>Users can decide which profiles to show as it is only based on the nonce. An Identity can create an Identity Profile and reuse it across interaction with different actors, for example in the case of a Profile with all their business information just by reusing the same nonce. For interactions that require the maximum level of privacy, an Identity can create a single-use Identity Profile by choosing a random nonce and never reusing it again. </p> <ul> <li>Reusability of claims across different profiles</li> </ul> <p>Users can get claims issued to an Identity Profile (or to their Genesis ID) and generate proof, based on these claims, from a different Identity Profile. The Verifier will be only able to see a valid proof coming from the Identity Profile that the user decided to use. No connection between the two identities is leaked.</p> <p>Despite being able to create multiples Identity Profiles, the control of the Identity is still still managed by the underlying Private Key.</p>"},{"location":"protocol/spec/#gist-new","title":"GIST (NEW)","text":"<p>GIST, namely Global Identities State Tree, is a Sparse Merkle Tree that contains the state of all the identities using Iden3 protocol. In particular, each leaf is indexed by the hash of its <code>Genesis ID</code> (key of the leaf) and contains the most recent state of that Identity (value of the leaf). </p> <p>The choice of using the hash of the Genesis ID as key of the leaf (instead of the Genesis ID itself) is to avoid that all the leaf accumulates in the same branch of the tree, since the Genesis ID has a fixed prefix. This would make the tree very unbalanced and inefficient. Instead, by using the hash of the Genesis ID, we randomize the position of the leaf in the tree, making it more balanced.</p> <p>The GIST is stored inside the State Contract. Every time a user executes a State Transition function, the new state of an identity is added to the GIST stored on-chain</p> <pre><code>gistTree.add(H(genesisID), state)\n</code></pre> <p>This design allows users to prove ownership of an Identity by proving that this is included in the GIST without revealing which one is their Genesis ID!</p>"},{"location":"protocol/spec/#identity-ownership","title":"Identity Ownership","text":"<p>We prove the identity ownership inside a zkSNARK proof. This means that the user can generate a zk-proof that s/he knows a <code>private key</code> corresponding to the <code>operational key for authorization</code> claim added to the Claims Tree, without revealing the <code>claim</code> and its position. This is coded inside a circom circuit, which can be used in other circuits (such as the <code>id state update</code> circuit).</p> <p>The full circuit can be found here: https://github.com/iden3/circuits/blob/master/circuits/lib/idOwnershipBySignature.circom</p>"},{"location":"protocol/spec/#identity-key-rotation","title":"Identity Key Rotation","text":"<p>An identity can self-issue and revoke many <code>private keys</code> and the corresponding <code>claims</code> of the type <code>operational key authorization</code>, enabling key rotation. To support verification of such claims, an identity state should be publicly available on the blockchain. An identity can publish the state to the blockchain directly or via the Relay.</p> <p>Any private key for which a corresponding claim exists in the Identity Claims Tree and does not exist in the Identity Revocation Tree, can be used to create a zero-knowledge proof for valid credentials. Such proof should pass verification by a verifier as it is able to check the latest identity state in the blockchain.</p> <p>In the same way, any valid and non-revoked identity private key can be used to create a valid ZK proof for the Identity State Transition Function.</p> <p>Note</p> <p>An identity may lose some privacy while disclosing its state to a verifier, which can track all the proofs of the same identity in that manner. However, this issue can be mitigated if the identity state is published to the blockchain via a Relay. In such a case, only the Relay state needs to be disclosed to a verifier.</p>"},{"location":"protocol/spec/#identity-revocation","title":"Identity Revocation","text":"<p>When an identity revokes all the <code>claims</code> of the type <code>operational key authorization</code>, it is considered <code>revoked</code> as this identity can no longer create proofs.</p>"},{"location":"protocol/spec/#interaction-between-identity-and-claims","title":"Interaction between Identity and Claims","text":""},{"location":"protocol/spec/#identity-state-update","title":"Identity State Update","text":"<p>The Identity State Update is the procedure used to update information about what this identity has claimed. This involves three different actions:</p> <ul> <li>Add a claim.</li> <li>Update a claim (by incrementing the version and changing the claim value part).</li> <li>Revoke a claim.</li> </ul>"},{"location":"protocol/spec/#definitions","title":"Definitions","text":"<ul> <li><code>IdState</code>: Identity State</li> <li><code>ClT</code>: Claims Tree<ul> <li><code>ClR</code>: Claims Tree Root</li> </ul> </li> <li><code>ReT</code>: Revocation Tree<ul> <li><code>ReR</code>: Revocation Tree Root</li> </ul> </li> <li><code>RoT</code>: Roots Tree<ul> <li><code>RoR</code>: Roots Tree Root</li> </ul> </li> </ul> <p>The <code>IdState</code> (Identity State) is calculated by concatenating the roots of the three user trees:</p> <ul> <li><code>IdState</code>: <code>H(ClR || ReR || RoR)</code> where <code>H</code> is the Hash function defined by the Identity Type (for example, Poseidon).</li> </ul> <p>All trees are SMT (sparse Merkle trees) and use the hash function defined by the Identity Type.</p> <ul> <li>Leaves in <code>ClT</code> (Claims Tree) are claims ((4 + 4) * 253 bits = 253 bytes)</li> </ul> <p>See Claim Structure</p> <ul> <li>Leaves in <code>ReT</code> (Revocation Tree) are Revocation Nonce + Version (64 bits + 32 bits = 12 bytes) <pre><code>Revocation Tree Leaf:\nleaf: [ 64 bits ] revocation nonce\n      [ 32 bits ] version\n      [157 bits ] 0\n</code></pre></li> <li>Leaves in <code>RoT</code> (Roots Tree) are tree roots (from the Claims Tree) (253 bits = 32 bytes) <pre><code>Roots Tree Leaf:\nleaf: [253 bits ] tree root\n</code></pre></li> </ul> <p></p> <p>Identity State Diagram for Direct Identity</p> <p>As seen in the diagram, only the <code>IdState</code> is stored on the blockchain.  In order to save the stored bytes on the blockchain, it is desirable that only one \"hash\" representing the current state of the Identity is stored on the smart contract. This one \"hash\" is the <code>IdState</code> (Identity State), which is linked to a timestamp and a block on the blockchain.</p> <p>All the public data must be made available for any holder so that they can build fresh Merkle tree proofs of both the <code>ReT</code> and <code>RoT</code>.  This allows the holder to:</p> <ul> <li>Prove recent non-revocation / \"current\" version without interaction with the issuer.</li> <li>Hide a particular <code>ClR</code> from all the other<code>ClR</code>s to avoid an issuer from discovering a claim hidden behind a ZK proof. For this purpose, <code>ClR</code> is added to <code>RoR</code>.</li> </ul> <p>The place and the method to access the publicly available data are specified in the Identities State smart contract. Two possible initial options are:</p> <ul> <li>IPFS, by adding a link to an IPNS address (example: <code>ipfs://ipns/QmSrPmbaUKA3ZodhzPWZnpFgcPMFWF4QsxXbkWfEptTBJd</code>), which contains a standardized structure of the data.</li> <li>HTTPS, by adding a link to an HTTPS endpoint (example: <code>https://kyc.iden3.io/api/v1/public-state/aabbccdd</code>), which offers the data following a standardized API.</li> </ul>"},{"location":"protocol/spec/#publish-claims","title":"Publish Claims","text":"<p>The first step in publishing a claim involves adding a new leaf to the <code>ClT</code>, which updates the identity <code>ClR</code>. Claims can be optionally published in batches, adding more than one leaf to the <code>ClT</code> in a single transaction. After the <code>ClT</code> has been updated, the identity must follow an Identity State Update so that anyone is able to verify the newly added claims. This involves adding the new <code>ClR</code> to the <code>RoT</code>, which in turn will update the <code>RoR</code>. After that, the new <code>IdState</code> is calculated and through a transaction it is updated in the Identities State Smart Contract (from now on, referred to as \"the smart contract\") on the blockchain. Once the updated <code>IdState</code> is in the smart contract, anyone can verify the validity of the newly added claims.</p> <p>The procedure to update the <code>IdState</code> in the smart contract can be achieved with the following criteria:</p> <ul> <li>Bad scalability (no batch), good privacy, and correctness: The identity uploads the new <code>IdState</code> to the smart contract with proof of a correct transition from the old <code>IdState</code> to the new one. Only one claim is added to the <code>ClT</code> in the transition.</li> <li>Good scalability (batch), good privacy, and correctness: Same as before, but many claims are added (batch) in the transition (with a single proof for all newly added claims)</li> <li>Good scalability (batch), good privacy but no correctness: The identity uploads the new <code>IdState</code> to the smart contract, without proving correctness on the transition.</li> </ul> <p>The criteria for correctness are as follows:</p> <ul> <li>Revocation of a claim cannot be reverted.</li> <li>Updatable claims are only updated with increasing versions, and only one version is valid at a time.</li> </ul> <p>To have or to not have the guarantee of the correctness is specified in the Identity Type so that any verifier knows about the guarantees provided by the protocol for the issuer claims.</p> <p>Note</p> <p>Good scalability refers to the verification process and the costs related to the smart contract. Batching with zkSNARKs can have a high computation load on the prover.</p>"},{"location":"protocol/spec/#revocation-tree","title":"Revocation Tree","text":"<p>Sometimes, it is desirable for an identity to invalidate a statement made through a claim. For regular claims, this involves revoking (a process that is ideally irreversible) and allows any verifier to be aware that an already published claim is made invalid by the issuer's identity. Similarly, for updatable claims, there must be a mechanism to invalidate old versions when a new one is published. Since confirming the current validity of a claim is a parallel process to confirming that a claim was published at some point, the \"current validation\" process can be separated.</p> <p>Separating these two processes allows a design in which the <code>ClT</code> (Claim Tree) remains private, but the revocation/version information is public, allowing a holder to generate a fresh proof of the \"current validity\" without requesting access to the private <code>ClT</code>.</p> <p>To achieve this, every Identity has a <code>ClT</code> (Claim Tree) and a separate <code>ReT</code>(Revocation Tree). While the Claim Tree would be private and only the root public, the revocation tree would be entirely public. The roots of both the trees (<code>ClT</code> and <code>ReT</code>) are linked via the <code>IdState</code> (Identity State) which is published in the smart contract. The Revocation Tree could be published in IPFS or other public storage systems.</p> <p>Proving that a claim is valid (and thus not revoked/updated) consists of two proofs:</p> <ul> <li>Prove that the claim was issued at some time t (this proof is generated once by the issuer and uses a <code>IdState</code>-<code>ClR</code> at time t stored in the smart contract).</li> <li>Prove that the claim has not been revoked/updated recently (this proof is generated by the holder with a recent <code>ReR</code> (Revocation Tree Root) by querying the public <code>ReT</code> (Revocation Tree), and verified against a recent <code>IdState</code>).</li> </ul>"},{"location":"protocol/spec/#revoke-claims","title":"Revoke Claims","text":"<p>To prevent revealing anything about the content of the claim in the <code>ReT</code>, the claim contains a revocation nonce in the value part, which is added as a leaf in the <code>ReT</code> to revocate the claim.</p> <p>To prevent reversing revocation of a claim, the <code>ReT</code> needs to follow some transition rules like <code>ClT</code>, enforced by a ZK proof (for space and verification efficiency).</p> <p>Apart from the revoking procedure, there is a method to define the validity of a claim based on expiration, by explicitly setting an expiration date in the claim (See Claim Structure). Revoking and Expiration are compatible methods to invalidate claims.</p>"},{"location":"protocol/spec/#update-claims","title":"Update Claims","text":"<p>To update a claim, a new claim is added to the <code>ClT</code> with an increased version value in the index position of the claim (notice that the previous version of the claim is not touched). Then, a leaf is added to the <code>ReT</code> containing the revocation nonce and the highest invalid version (that is, all the claims with that nonce and version equal or lower to the one in the leaf are invalid). This means that when a claim is updated, the same revocation nonce is used in the claim.</p> <p>To prevent downgrading the version of a claim, and forcing to have only one valid updatable claim at a time, the <code>ReT</code> needs to follow the transition rules (like the <code>ClT</code> does) enforced by a ZK proof (for space and verification efficiency).</p> <p>Updating and revoking are compatible methods to invalidate claims: an updatable claim can be revoked, which means no future (or past) updates would be valid.</p> <p>In case a claim needs to be revoked completely, without the possibility to update, the highest version and the revocation nonce should be added to the <code>ReT</code>.</p>"},{"location":"protocol/spec/#prove-claims-credentials","title":"Prove Claims (Credentials)","text":"<p>Nomenclature - MTP: Merkle Tree Proof. The list of siblings in a path from a leaf to the root.</p>"},{"location":"protocol/spec/#prove-that-a-claim-was-issued-at-time-t","title":"Prove that a Claim was Issued at Time t","text":"<ul> <li>Requires proving a link between the claim and <code>IdState_t</code> (Identity State at time t) published in the smart contract. This proof requires:<ul> <li>Claim</li> <li>t </li> <li>MTP Claim -&gt; <code>ClR_t</code></li> <li><code>RoR_t</code> (Roots Tree at time t)</li> <li><code>ReR_t</code> (Revocation Tree Root at time t)</li> <li><code>IdState_t</code></li> </ul> </li> </ul> <p>where <code>t</code> is any time.</p>"},{"location":"protocol/spec/#prove-that-the-claim-is-currently-valid","title":"Prove that the Claim is Currently Valid","text":""},{"location":"protocol/spec/#prove-that-the-claim-hasnt-been-revoked-recently","title":"Prove that the Claim Hasn't Been Revoked Recently","text":"<ul> <li>Requires proving the inexistence of a link between the claim revocation nonce and a recent <code>IdState_t</code> (<code>t</code> must be recent according to the verifier requirements [1]) published in the smart contract. This proof requires:<ul> <li>Claim (Nonce)</li> <li>t (Recent Time)</li> <li>MTP !Nonce -&gt; <code>ReR_t</code></li> <li><code>ClR_t</code></li> <li><code>RoR_t</code></li> <li><code>IdState_t</code></li> </ul> </li> </ul> <p>[1] The verifier needs to decide a time span to define how recent the <code>IdState_t</code> used in the proof needs to be.  Using the current <code>IdState</code>instead of recent could lead to data races, so it is better to select an <code>IdState</code> that is no more than X minutes old.</p>"},{"location":"protocol/spec/#proof-of-last-version","title":"Proof of Last Version","text":"<p>This is very similar to proving that a claim has not been recently revoked except that in this case, not only the nonce in the claim is checked, but also the version.</p> <ul> <li>Requires proving the inexistence of a link between the claim revocation nonce version and a recent <code>IdState_t</code> (<code>t</code> must be recent according to the verifier requirements [1]) published in the smart contract.  This proof requires:<ul> <li>Claim (Nonce, Version)</li> <li>t</li> <li>MTP !(Nonce, Version) -&gt; <code>ReR_t</code></li> <li><code>ClR_t</code></li> <li><code>RoR_t</code></li> <li><code>IdState_t</code></li> </ul> </li> </ul> <p>Where <code>t</code> is a recent time.</p>"},{"location":"protocol/spec/#proof-of-non-expiration","title":"Proof of Non-Expiration","text":"<p>A claim can be made expirable by setting an expiration flag in the options and specifying an expiration date in the Unix timestamp format in the corresponding claim value part (see Claim Format).</p>"},{"location":"protocol/spec/#zero-knowledge-proof-of-valid-credentials","title":"Zero-knowledge Proof of Valid Credentials","text":"<p>A zero-knowledge proof allows hiding some information about a claim while proving that it was issued by a particular identity and that it is currently valid. The same checks mentioned in the previous sections are performed:</p> <ul> <li>Prove that a claim was issued at least at time t.</li> <li>Prove that the claim is currently valid.</li> </ul> <p>In the proof that shows \"that a claim was issued at time at least t\", there is an additional part that is added to hide a particular <code>IdState_t1</code> that is used (in order to hide the claim from the issuer). The proof then requires:</p> <pre><code>- Claim\n- t\n- MTP Claim -&gt; `ClR_t1`\n- `RoR_t1` (Roots Tree at time t1)\n- `ReR_t1` (Revocation Tree Root at time t1)\n- `IdState_t1`\n- MTP `ClR_t1` -&gt;`RoR_t2`\n- `ClR_t2` (Claims Tree Root at time t2)\n- `ReR_t2` (Revocation Tree Root at time t2)\n- `IdState_t2`\n</code></pre> <p>Where <code>t1</code> is any time and <code>t2</code> is the recent time.</p> <p>The full circuit can be found at: https://github.com/iden3/circuits/tree/master/circuits/lib</p>"},{"location":"protocol/template-circuits/","title":"Template Circuits","text":"<p>The template circuits are not are not used independently inside Iden3 protocols but rather as a building blocks inside the main circuits. </p> <p>Note: not all the templates are described here but only a few of them. Check Iden3 Circuits and Iden3 Circomlib to see all the templates.</p>"},{"location":"protocol/template-circuits/#idownershipbysignature","title":"idOwnershipBySignature","text":"<ul> <li>Github</li> </ul>"},{"location":"protocol/template-circuits/#inputs","title":"Inputs","text":"Input Description userState Identity State of the prover userClaimsTreeRoot Prover's Claims Tree Root userAuthClaimMtp[nLevels] Merkle Tree Proof of Auth Claim inside Prover's Claims tree userAuthClaim[8] Prover's Auth Claim userRevTreeRoot Prover's Revocation Tree Root userAuthClaimNonRevMtp[nLevels] Merkle Tree Proof of non membership of Auth Claim inside Prover's Revocation Tree userAuthClaimNonRevMtpNoAux Flag that indicates whether to check the auxiliary Node userAuthClaimNonRevMtpAuxHi Auxiliary Node Index userAuthClaimNonRevMtpAuxHv Auxiliary Node Value userRootsTreeRoot Prover's Roots Tree Root challenge Message to be signed by the prover challengeSignatureR8x Signature of the challenge (Rx point) challengeSignatureR8y Signature of the challenge (Ry point) challengeSignatureS Signature of the challenge (S point)"},{"location":"protocol/template-circuits/#scope","title":"Scope","text":"<ul> <li>Verifies that the <code>signature</code> was performed by the key contained in the <code>authClaim</code> and performs further verification on the auth claim using the <code>VerifyAuthClaimAndSignature(nLevels)</code> template</li> <li>The <code>state</code> generated by hashing the three roots should match the expected state from the blockchain (or be the genesis state) using the <code>checkIdenStateMatchesRoots()</code> template</li> </ul>"},{"location":"protocol/template-circuits/#verifyauthclaimandsignature","title":"VerifyAuthClaimAndSignature","text":"<ul> <li>Github</li> </ul>"},{"location":"protocol/template-circuits/#inputs_1","title":"Inputs","text":"Input Description claimsTreeRoot Prover's Claims Tree Root authClaimMtp[nLevels] Merkle Tree Proof of Auth Claim inside Prover's Claims tree authClaim[8] Prover's Auth Claim revTreeRoot Prover's Revocation Tree Root userAuthClaimNonRevMtp[nLevels] Merkle Tree Proof of non membership of Auth Claim inside Prover's Revocation Tree userAuthClaimNonRevMtpNoAux Flag that indicates whether to check the auxiliary Node userAuthClaimNonRevMtpAuxHi Auxiliary Node Index userAuthClaimNonRevMtpAuxHv Auxiliary Node Value challenge Message to be signed by the prover challengeSignatureR8x Signature of the challenge (Rx point) challengeSignatureR8y Signature of the challenge (Ry point) challengeSignatureS Signature of the challenge (S point)"},{"location":"protocol/template-circuits/#scope_1","title":"Scope","text":"<ul> <li>The schema hash of the claim must match the expected AUTH_SCHEMA_HASH (hardcoded inside the circuit). Verification performed using the <code>verifyCredentialSchema()</code> template</li> <li>The authClaim exists inside the claims tree root by using the <code>checkClaimExists()</code> template</li> <li>The authClaim hasn't been revoked, namely verifies that the authClaim is not included inside the revocation tree root, using the <code>checkClaimNotRevoked()</code> template</li> <li>Verifies that the signature on the challenge has been performed by the publickey contained in the authClaim using the <code>checkDataSignatureWithPubKeyInClaim()</code> template</li> </ul>"},{"location":"protocol/zklogin/","title":"Server-side Login (ZKP Login)","text":""},{"location":"protocol/zklogin/#introduction","title":"Introduction","text":"<p>Iden3 is a Self-Sovereign Identity (SSI) solution that allows users to leverage their pre-existing validated identities. With SSI, they are able to prove they are who they claim to be based on the zero-knowledge proofs. One of the direct applications of the iden3 technology is to allow web applications to reuse these identities for logging into their portals.</p>"},{"location":"protocol/zklogin/#login-workflow","title":"Login Workflow","text":"<p>In a simple example, an application requests a user identifier; this is done through the zero-knowledge proof (zk proof) generation. The server generates an authentication request.</p> <p>Auth request</p> <pre><code>    {\n      \"type\": \"https://iden3-communication.io/authorization-request/v1\",\n      \"data\": {\n        \"callbackUrl\": \"https://test.com/callbackurl\",\n        \"audience\": \"1125GJqgw6YEsKFwj63GY87MMxPL9kwDKxPUiwMLNZ\",\n        \"scope\": [\n            {\n              \"circuit_id\": \"auth\",\n              \"type\": \"zeroknowledge\",\n              \"rules\": {\n                  \"challenge\": 12345\n              }\n          }\n       ]\n      }\n    }\n</code></pre> <p>Shown above is an example of an authorization request. Scope field is a set of objects that describes an array of proofs that must be generated on a user device and presented later. Each scope member has a unique definition of a circuit that must be used and a set of rules (public inputs) that must be applied.</p> <p>This message can be delivered to a user through different communication channels: QR code, email, deep-linking, etc. On scanning, mobile needs to implement the following:</p> <ol> <li>Parse the authorization request and understand which proof handler it should use.</li> <li>Resolve the verifier identifier if required.</li> <li>Generate proofs using a specific handler. It can be a signature proof or a zero-knowledge proof.</li> <li>Prepare an authentication response message.</li> </ol> <p>On mobile, a user generates the ZK proof using auth circuit that will prove identity ownership, and send the response to the callback URL.</p> <p>Auth response</p> <pre><code>{\n  \"type\": \"https://iden3-communication.io/authorization-response/v1\",\n  \"data\": {\n    \"scope\": [\n      {\n        \"type\": \"zeroknowledge\",\n        \"circuit_id\": \"auth\",\n        \"pub_signals\": [\n          \"371135506535866236563870411357090963344408827476607986362864968105378316288\",\n          \"12345\",\n          \"16751774198505232045539489584666775489135471631443877047826295522719290880931\"\n        ],\n        \"proof_data\": {\n          \"pi_a\": [\n            \"8286889681087188684411199510889276918687181609540093440568310458198317956303\",\n            \"20120810686068956496055592376395897424117861934161580256832624025185006492545\",\n            \"1\"\n          ],\n          \"pi_b\": [\n            [\n              \"8781021494687726640921078755116610543888920881180197598360798979078295904948\",\n              \"19202155147447713148677957576892776380573753514701598304555554559013661311518\"\n            ],\n            [\n              \"15726655173394887666308034684678118482468533753607200826879522418086507576197\",\n              \"16663572050292231627606042532825469225281493999513959929720171494729819874292\"\n            ],\n            [\n              \"1\",\n              \"0\"\n            ]\n          ],\n          \"pi_c\": [\n            \"9723779257940517259310236863517792034982122114581325631102251752415874164616\",\n            \"3242951480985471018890459433562773969741463856458716743271162635077379852479\",\n            \"1\"\n          ],\n          \"protocol\": \"groth16\"\n        }\n      }\n    ]\n  }\n}\n</code></pre> <p>The client, after receiving an authorization response, performs the verification process:</p> <ol> <li>Verification with zero-knowledge proof.</li> <li>Extraction of metadata (auth and circuit-specific).</li> <li>Verification of the user identity states.</li> <li>Verification of the circuit's public inputs (e.g. issuer state).</li> </ol>"},{"location":"protocol/zklogin/#authentication-based-on-zero-knowledge-proof","title":"Authentication based on Zero-knowledge Proof","text":"<p>ZK proof is based on the Circom 2.0 language.</p> <p>Auth Circuit Repository: auth</p> <p>The circuit verifies that the user is the owner of the identity and his auth key is not revoked in the provided user state.</p>"},{"location":"protocol/zklogin/#prerequisites","title":"Prerequisites","text":"<p>The identity wallet should be installed.</p>"},{"location":"protocol/zklogin/#integration","title":"Integration","text":""},{"location":"protocol/zklogin/#back-end","title":"Back-end","text":"<p>Generate Auth Request</p> <pre><code>request := auth.CreateAuthorizationRequest(\"&lt;challenge&gt;\",\"&lt;verifier identity|app-url&gt;\", \"&lt;callbackURI&gt;\") // create auth request\n</code></pre> <p>Validate Auth Request</p> <pre><code>// unpack raw message\nmessage, err := packer.Unpack(msgBytes) \n// call library to verify zkp proofs\nerr = auth.VerifyProofs(message)  \n// extract metadata\ntoken, err := auth.ExtractMetadata(message)\n// verify state\nstateInfo, err := token.VerifyState(ctx.Background(),\"&lt; rpc url &gt;\", \"&lt; state contract address &gt;\")\n</code></pre> <p>In future releases of the auth library, the verification procedure will be simplified and optimized for a verifier.</p>"},{"location":"protocol/zklogin/#front-end","title":"Front-end","text":"<p>On the front-end, you need to embed a button to initiate the login process. After this button is pressed, the front-end makes a request to the back-end to generate an authentication request and displays it in the QR code. When a user scans the QR code, the phone generates a zk proof and sends this proof to the call-back URL from the QR code. Currently, we are working on the js-iden3-auth library.</p>"},{"location":"protocol/zklogin/#tutorial-a-simple-go-application","title":"Tutorial: A Simple Go Application","text":"<p>For this, we need a web server with two endpoints:</p> <ul> <li>GET /sign-in should return auth request</li> <li>POST /call-back endpoint to receive a callback request from the phone and validate the same</li> </ul> <p>Let us write a simple web server:</p> <pre><code>func main() {\n\n    http.HandleFunc(\"/sign-in\", signIn)\n    http.HandleFunc(\"/call-back\", callBack)\n\n    http.ListenAndServe(\":8001\", nil)\n}\n\nfunc signIn(w http.ResponseWriter, req *http.Request) {\n\n}\n\nfunc callBack(w http.ResponseWriter, req *http.Request) {\n\n}\n</code></pre>"},{"location":"protocol/zklogin/#auth-package","title":"Auth Package","text":"<p>Add the authorization package to the project.</p> <pre><code>go get https://github.com/iden3/go-iden3-auth\n</code></pre>"},{"location":"protocol/zklogin/#sign-in","title":"Sign-in","text":"<p>To generate a zk auth request, we need a callback URL where we will receive a response from the mobile application along with an authentication response and the verifier's identity. </p> <p>The go-iden3-auth library contains a method for generating the authentication request.</p> <p>[Description]</p> <pre><code>func CreateAuthorizationRequest(challenge int64, aud, callbackURL string) *types.AuthorizationMessageRequest\n</code></pre> <p>Now, we are ready to generate the auth request:</p> <pre><code>const CallBackUrl      = \"http:localhost:8001/call-back\"\nconst VerifierIdentity = \"1125GJqgw6YEsKFwj63GY87MMxPL9kwDKxPUiwMLNZ\"\n\nfunc signIn(w http.ResponseWriter, req *http.Request) {\n\n    request := auth.CreateAuthorizationRequest(10, VerifierIdentity, callBackURI)\n\n    msgBytes, _ := json.Marshal(request) // error handling ommited for simplification\n\n    w.Header().Set(\"Content-Type\", \"application/json\")\n    w.WriteHeader(http.StatusOK)\n    w.Write(msgBytes)\n}\n</code></pre>"},{"location":"protocol/zklogin/#callback","title":"Callback","text":"<p>When we receive a callback request with a zk response, to validate, we need to take the following actions:</p> <ol> <li>Validate zk proof and make sure that the proof is valid.</li> <li>Validate identity's state on-chain so as to verify that the user identity state is valid and his/her auth keys are not revoked.</li> </ol> <p>First, let\u2019s validate the zk proof. For this, we have the following function:</p> <pre><code>func VerifyProofs(message types.Message) (err error)\n</code></pre> <p>But before we can call it, we need to unpack raw bytes to a message. Packer can be used to process the encrypted message for future releases.</p> <pre><code>p := &amp;packer.PlainMessagePacker{}\n// Unpack msg\nmessage, _ := p.Unpack(msgBytes)    \n// verify zkp\nproofErr := auth.VerifyProofs(message)\n</code></pre> <p>Now that the zk proof is verified, we can check the identity's status on-chain.</p> <p>First, we need access the RPC URL and the address of the identity's smart contract:</p> <pre><code>const rpc = \"https://polygon-mumbai.infura.io/v3/&lt;your-token&gt;\"\nconst IdentityContract = \"0x3e95a7B12e8905E01126E1beA3F1a52D1624A725\"\n</code></pre> <p>Before we can verify a state, we need to extract the metadata and then verify it on-chain.</p> <pre><code>token, _:= auth.ExtractMetadata(message)\n\n// verify match identifier with the state on chain\nstateInfo, err := token.VerifyState(ctx, rpc, IdentityContract)\n</code></pre>"},{"location":"protocol/zklogin/#verification-procedure","title":"Verification Procedure","text":""},{"location":"protocol/zklogin/#zero-knowledge-proof-verification","title":"Zero-knowledge Proof Verification","text":"<p>Groth16 proofs are now supported by the auth library.</p> <p>Verification keys for the circuits can be referred to from the library. In the future, they can be resolved from the circuit registries.</p>"},{"location":"protocol/zklogin/#extraction-of-metadata","title":"Extraction of Metadata","text":"<p>Each circuit has a schema of its public inputs that links the public signal name to its position in the resulting array. This allows extracting user identifiers and challenges from the proof for authentication.</p> <p>Other signals are added to the user token (scope field) as attributes of a specific circuit. The circuit's public signal schemas are known by this library or can be retrieved from a registry.</p>"},{"location":"protocol/zklogin/#verification-of-user-identity-states","title":"Verification of User Identity States","text":"<p>The blockchain verification algorithm is used to:</p> <ol> <li> <p>Get state from the blockchain (address of the id state contract and URL must be provided by the caller of the library):</p> <ol> <li>Empty State is Returned: It indicates that the identity state has not been updated or the updated state has not been published. We need to compare the id with the state. If they are different, it is not the genesis state of the identity and it is not valid.</li> <li>Non-empty State is Returned and Equals to the State Provided in Proof: This indicates that the user state is new and we work with the latest user state.</li> <li>Non-empty State is Returned and is not Equal to the State Provided in Proof: Gets the time of the state transition. The verification party can make a decision if it can accept this state based on that time frame.</li> </ol> </li> <li> <p>Accept or reject the provided state (The verification party makes this decision). </p> </li> </ol>"},{"location":"protocol/zklogin/#verification-of-circuits-public-signals","title":"Verification of Circuit's Public Signals","text":"<p>This verification includes the following: 1. Check if the issuer states of the provided claim proofs are published on the blockchain (same as for identity state). 2. Check the query signals so that the claim schema and the specific values can be verified.</p>"},{"location":"publications/publications/","title":"Publications","text":""},{"location":"publications/publications/#research-papers","title":"Research Papers","text":"<ul> <li>Baby Jubjub Elliptic Curve (pdf)</li> <li>EdDSA For Baby Jubjub Elliptic Curve with MiMC-7 Hash (pdf)</li> <li>4-bit Window Pedersen Hash on the Baby Jubjub Elliptic Curve (pdf)</li> <li>Sparse Merkle Trees (pdf)</li> </ul>"},{"location":"publications/publications/#videos","title":"Videos","text":"<ul> <li>Introduction to Iden3</li> <li>Circom and SnarkJS</li> <li>Scalable Distributed Identity Infrastructure Using Zero-knowledge Proofs to Guarantee Privacy</li> <li>Websnarks - DappCon 2019</li> <li>Big ZkSNARK Circuits for Zk-rollups with Circom - EthCC 2020</li> </ul>"},{"location":"publications/publications/#slides","title":"Slides","text":"<ul> <li>Introduction to Iden3</li> <li>Circom and SnarkJS</li> <li>Scalable Distributed Identity Infrastructure Using Zero-knowledge Proofs to Guarantee Privacy</li> <li>Big ZkSNARK Circuits for Zk-rollups with Circom - EthCC 2020</li> </ul>"},{"location":"services/libraries/","title":"Iden3 Protocol Libraries","text":"<ul> <li> <p>Crypto Library (go-iden3-crypto) Implementation of Poseidon Hash and Baby JubJub Eliptic Curve</p> </li> <li> <p>Merkle Tree SQL Library (go-merkletree-sql) Implementation of Sparse Merkle Tree</p> </li> <li> <p>Core Library (go-iden3-core) Identity Core Primitives</p> </li> <li> <p>Circuits (circuits) Identity Circuits</p> </li> <li> <p>Go Circuits (go-circuits) Library for Transforming Go-core Primitives to JSON Inputs for Identity Circuits</p> </li> <li> <p>Prover Server (prover-server) Wrapper on SnarkJSfor Zk-proof Generation</p> </li> <li> <p>Authorization Library (go-iden3-auth) Library for Authentication with Zk-proof Verification </p> </li> </ul>"},{"location":"services/login-protocol/","title":"Login Protocol","text":""},{"location":"services/login-protocol/#introduction","title":"Introduction","text":"<p>The login protocol is based on the signature protocol, in which a user signs a packet using an authorized kSign key. For the login case, the user desires to assert a particular identity (an Ethereum address in this case) to a server so that s/he is allowed access to the service while being identified.</p> <p></p>"},{"location":"services/login-protocol/#assumptions","title":"Assumptions","text":"<ul> <li>Secure connection between wallet and server.</li> <li>Secure connection between web client and server.</li> <li>Wallet authenticates the server in the connection.</li> <li>Web client authenticates the server in the connection.</li> </ul>"},{"location":"services/login-protocol/#what-is-required","title":"What is Required?","text":"<ul> <li>Server authenticates the Ethereum address and Ethereum name from the wallet.</li> <li>The user transfers the authentication from the wallet to the web client.</li> </ul>"},{"location":"services/login-protocol/#protocol-flow","title":"Protocol Flow","text":"<p>Challenges contain a cryptographic nonce and have a timeout that indicates the validity of the nonce in the challenge. A signed challenge with a timed out nonce must be rejected by the server. The server must store a list of the nonces that have not timed out and have not been signed yet to guarantee the freshness.</p> <p>A cryptographic nonce must be generated securely and must be long enough to avoid collisions (we use 256 bits).</p>"},{"location":"services/login-protocol/#signature-protocol-v01-specifications","title":"Signature Protocol v0.1: Specifications","text":"<p>A signature may be requested as follows:</p> <pre><code>{\n  header: {\n    typ: iden3.sig.v0_1\n  }\n  body: {\n    type: TYPE\n    data: DATA\n  }\n}\n</code></pre> <p>Depending upon the signature protocol specifications, a user generates a packet that may contain data from the signature request or can be created from scratch. The packet contains a header and a payload, is serialized, and signed following the JWS standard. Usually, the <code>form</code> is filled in by the user, and <code>data</code> is copied from a request.</p> <p>The structures of the <code>data</code> and the <code>form</code> in the payload are specified by the <code>type</code> (what is being signed) in the payload. The rest of the elements are specified by the <code>typ</code> (signature packet) in the header.</p> <pre><code>JWS_PAYLOAD = {\n  type: TYPE\n  data: DATA\n  form: FORM\n  ksign: str # ksing public key in compressed form\n  proofKSing: proofClaim # Proof of authorize k sign claim (which contains the public key in compressed form)\n}\n\nJWS_HEADER = {\n  typ: iden3.sig.v0_1\n  iss: str # Ethereum Address\n  iat: uint # issued at time, unix timestamp\n  exp: uint # expiration time, unix timestamp\n  alg: ? # algorithm\n}\n\nJWS_SIGN(JWS_HEADER, JWS_PAYLOAD)\n</code></pre> <p>Each signature request <code>type</code> has a view representation for the user, where the <code>data</code> and <code>form</code> are presented. Some of the values may be hidden from the user when necessary, but only if doing so doesn\u2019t compromise the security of the user. In the request view, the user has the ability to pick some elements of the <code>form</code>. <code>ksign</code> is the compressed public key of a secp256k ECDSA key pair. The <code>proofKSing</code> contains a KSign Authorize Claim for a secp256k public key.</p> <p>As <code>JWS_HEADER.alg</code>, we will use a custom algorithm (not defined in the JWS standard): \u201cEK256K1\u201d, which is ECDSA with secp256k1 curve and keccak as a hash function, the same signature algorithm configuration as is used in Ethereum.</p>"},{"location":"services/login-protocol/#auxiliary-data-structures","title":"Auxiliary Data Structures","text":"<pre><code>proofClaim: {\n    signature: signature # Relay root + date signed by relay\n    date: uint\n    leaf: claim\n    proofs: proofClaimPartial[]\n}\n\nproofClaimPartial: {\n    mtp0: mtp # merkle tree proof of leaf existence\n    mtp1: mtp # merkle tree proof of leaf non-existence\n    root: key # merkle tree root\n    aux: nil | { ver: uint, era: uint, idAddr: str } # Necessary data to construct SetRootClaim from root\n}\n</code></pre> <p>Usually, the relay returns the <code>proofClaim</code> data structure to prove that a claim is valid and is in the Merkle tree.</p>"},{"location":"services/login-protocol/#identity-assertion-v01-specifications","title":"Identity Assertion v0.1: Specifications","text":"<p>payload:</p> <pre><code>type: iden3.iden_assert.v0_1\ndata: {\n  challenge: nonce # 256 bits in base64\n  timeout: uint # seconds\n  origin: str # domain\n}\nform: {\n  ethName: str # ethereumName\n  proofAssignName: proofClaim # proof of claim Assign Name for ethName\n}\n</code></pre> <p>A session id, if required, can be computed from the challenge. This session id can be used to link the communication between the web service and the wallet service.</p> <p>view:</p> <pre><code>type: Identity Assertion\ndata: {\n  origin: str # domain\n}\nform: {\n  ethName: str # ethereum name\n}\n</code></pre>"},{"location":"services/login-protocol/#algorithms","title":"Algorithms","text":"<p>In the following sections, we will show an overview of the steps of the algorithms used for verification of the proofs and signatures used in the login protocol. The algorithms below consider the case in which there is a single trusted entity (identified by <code>relayPk</code>) that acts as a relay and as a domain name server.</p>"},{"location":"services/login-protocol/#signature-verification-algorithm","title":"Signature Verification Algorithm","text":"<pre><code>VerifySignedPacket(jwsHeader, jwsPayload, signature, relayPk):\n1. Verify jwsHeader.typ is 'iden3.sig.v0_1'\n2. Verify jwsHeader.alg is 'EK256K1'\n3. Verify that jwsHeader.iat &lt;= now() &lt; jwsHeader.exp \n4. Verify that jwsPayload.ksign is in jwsPayload.proofKSign.leaf\n5. Verify that jwsHeader.iss is in jwsPayload.proofKSign\n6. Verify that signature of JWS(jwsHeader, jwsPayload) by jwsPayload.ksign is signature\n7. VerifyProofOfClaim(jwsPayload.proofKSign, relayPk)\n</code></pre> <p>In step 4 above, we verify that the ksign used to sign the packet is authorized by the user and is identified by the jwsHeader.iss Ethereum address.</p>"},{"location":"services/login-protocol/#iden-assert-verification-algorithm","title":"Iden Assert Verification Algorithm","text":"<pre><code>VerifyIdenAssertV01(nonceDB, origin, jwsHeader, jwsPayload, signature, relayPk):\n1. Verify jwsPayload.type is 'iden3.iden_assert.v0_1'\n2. Verify jwsPayload.data.origin is origin\n3. Verify jwsPayload.data.challenge is in nonceDB and hasn't expired, delete it\n4. Verify that jwsHeader.iss and jwsPayload.form.ethName are in jwsPayload.proofAssignName.leaf\n5. VerifyProofOfClaim(jwsPayload.form.ethName, relayPk)\n</code></pre>"},{"location":"services/login-protocol/#proof-of-claim-verification","title":"Proof of Claim Verification","text":"<pre><code>VerifyProofOfClaim(p, relayPk):\n1. Verify signature of p.proofs[-1].root by relayPk is p.signature\n   let leaf = p.leaf\n2. loop for each proof in p.proofs:\n    2.1 Verify proof.mtp0 is existence proof\n    2.2 Verify proof.mtp0 with leaf and proof.root\n    2.3 Verify proof.mtp1 is non-existence proof\n    2.4 Verify proof.mtp1 with ClaimIncrementVersion(leaf) and proof.root\n        leaf = NewClaimSetRootClaim(p.root, p.aux.ver, p.aux.era, p.aux.ethAddr)\n</code></pre>"},{"location":"services/login-protocol/#iden3js-protocols","title":"iden3js Protocols","text":""},{"location":"services/login-protocol/#login-identity-assertion","title":"Login (Identity Assertion)","text":"<pre><code>Wallet                                   Service\n  +                                         +\n  |           signatureRequest              |\n  | &lt;-------------------------------------+ |\n  |                                         |\n  | +---+                                   |\n  |     |                                   |\n  |     |sign packet                        |\n  |     |                                   |\n  | &lt;---+                                   |\n  |              signedPacket               |\n  | +-------------------------------------&gt; |\n  |                                         |\n  |                                  +---+  |\n  |                      verify      |      |\n  |                      signedPacket|      |\n  |                                  |      |\n  |                                  +---&gt;  |\n  |                                         |\n  |                 ok                      |\n  | &lt;-------------------------------------+ |\n  |                                         |\n  |                                         |\n  |                                         |\n  +                                         +\n</code></pre> <p>Read the login protocol specifications here:</p>"},{"location":"services/login-protocol/#define-new-noncedb","title":"Define New NonceDB","text":"<pre><code>const nonceDB = new iden3.protocols.NonceDB();\n</code></pre>"},{"location":"services/login-protocol/#generate-new-request-for-identity-assert","title":"Generate New Request for Identity Assert","text":"<ul> <li>Input<ul> <li><code>nonceDB</code>: NonceDB class object</li> <li><code>origin</code>: Domain of the emitter of the request</li> <li><code>timeout</code>: Unix time format, valid until that date. For example, we can use 2 minutes (<code>2*60</code> seconds)</li> </ul> </li> <li> <p>Output</p> <ul> <li><code>signatureRequest</code>: <code>Object</code></li> </ul> <pre><code>const signatureRequest = iden3.protocols.login.newRequestIdenAssert(nonceDB, origin, 2*60);\n</code></pre> </li> </ul> <p>The <code>nonce</code> of the <code>signatureRequest</code> can be accessed as:</p> <pre><code>const nonce = signatureRequest.body.data.challenge;\n// nonce is the string containing the nonce value\n</code></pre> <p>We can add auxiliar data to the <code>nonce</code> in the <code>nonceDB</code> only one time:</p> <pre><code>const added = nodeDB.addAuxToNonce(nonce, auxdata);\n// added is a bool confirming if the aux data had been added.\n</code></pre>"},{"location":"services/login-protocol/#sign-packet","title":"Sign Packet","text":"<ul> <li>input<ul> <li><code>signatureRequest</code>: object generated in the     <code>newRequestIdenAssert</code> function</li> <li><code>userAddr</code>: Ethereum address of the user who signs the data packet</li> <li><code>ethName</code>: name assigned to the <code>userAddr</code></li> <li><code>proofOfEthName</code>: <code>proofOfClaim</code> of the <code>ethName</code></li> <li><code>kc</code>: iden3.KeyContainer object</li> <li><code>ksign</code>: KOperational authorized for the <code>userAddr</code></li> <li><code>proofOfKSign</code>: <code>proofOfClaim</code> of the <code>ksign</code></li> <li><code>expirationTime</code>: Unix time format, signature will be valid until that date</li> </ul> </li> <li> <p>output</p> <ul> <li><code>signedPacket</code>: <code>String</code></li> </ul> <pre><code>const expirationTime = unixtime + (3600 * 60);\nconst signedPacket = iden3.protocols.login.signIdenAssertV01(signatureRequest, usrAddr, ethName, proofOfEthName, kc, ksign, proofOfKSign, expirationTime);\n</code></pre> </li> </ul>"},{"location":"services/login-protocol/#verify-signed-packet","title":"Verify Signed Packet","text":"<ul> <li>input<ul> <li><code>nonceDB</code>: NonceDB class object</li> <li><code>origin</code>: Domain of the emitter of the request</li> <li><code>signedPacket</code>: Object generated in the <code>signIdenAssertV01</code> function</li> </ul> </li> <li> <p>output</p> <ul> <li><code>nonce</code>: Nonce object of the signedPacket that has been deleted from the nonceDB when the signedPacket is verified. If the verification fails, the nonce will be <code>undefined.</code></li> </ul> <pre><code>const verified = iden3.protocols.login.verifySignedPacket(nonceDB, origin, signedPacket);\n</code></pre> </li> </ul>"},{"location":"services/login-protocol/#rationale","title":"Rationale","text":"<p>In the following sections, you will find references to a few protocols on which our login protocol relies or takes inspiration from.</p>"},{"location":"services/login-protocol/#signature-format","title":"Signature Format","text":"<p>Use JSON to encode the object that will be signed.</p>"},{"location":"services/login-protocol/#json-signing-formats","title":"JSON Signing Formats","text":"<p>https://medium.facilelogin.com/json-message-signing-alternatives-897f90d411c</p> <ul> <li>JSON Web Signature (JWS)<ul> <li>Doesn\u2019t need canonicalization</li> <li>Allows signing arbitrary data (not only JSON)</li> <li>Widely used</li> </ul> </li> <li>JSON Cleartext Signature (JCS)</li> <li>Concise Binary Object Representation (CBOR) Object Signing</li> </ul> <p>https://matrix.org/docs/spec/appendices.html#signing-json</p> <ul> <li>Matrix JSON Signing<ul> <li>Allows having multiple signatures with different protocols for a single JSON</li> </ul> </li> </ul>"},{"location":"services/login-protocol/#possible-attacks","title":"Possible attacks","text":"<p>See WebAuth API, FIDO Threat Analysis</p>"},{"location":"services/login-protocol/#references","title":"References","text":"<ul> <li>https://en.wikipedia.org/wiki/OpenID</li> <li>https://en.wikipedia.org/wiki/OpenID_Connect</li> <li>https://en.wikipedia.org/wiki/IndieAuth</li> <li>https://fidoalliance.org/how-fido-works/</li> </ul>"},{"location":"services/login-protocol/#webauth-api","title":"WebAuth API","text":"<ul> <li>https://developer.mozilla.org/en-US/docs/Web/API/Web_Authentication_API</li> <li>https://w3c.github.io/webauthn/</li> <li>https://www.w3.org/TR/webauthn/</li> <li>https://www.webauthn.io/ (Demo)</li> </ul>"},{"location":"services/login-protocol/#fido-security-guarantees-and-how-they-are-achieved","title":"FIDO Security Guarantees and How They are Achieved:","text":"<ul> <li>https://fidoalliance.org/specs/fido-v2.0-id-20180227/fido-security-ref-v2.0-id-20180227.html#relation-between-measures-and-goals</li> </ul>"},{"location":"services/login-protocol/#fido-threat-analysis-and-mitigations","title":"FIDO Threat Analysis and Mitigations:","text":"<ul> <li>https://fidoalliance.org/specs/fido-v2.0-id-20180227/fido-security-ref-v2.0-id-20180227.html#threat-analysis Currently (2018-01-08) there\u2019s no support for iOS (Safari):</li> <li>https://developer.mozilla.org/en-US/docs/Web/API/Web_Authentication_API#Browser_compatibility</li> </ul>"},{"location":"services/login-protocol/#criticism","title":"Criticism:","text":"<ul> <li>https://www.scip.ch/en/?labs.20180424</li> </ul>"},{"location":"services/login-protocol/#example-code-of-server-verification","title":"Example Code of Server Verification:","text":"<ul> <li>https://github.com/duo-labs/webauthn/blob/fa6cd954884baf24fc5a51656ce21c1a1ef574bc/main.go#L336</li> <li>https://w3c.github.io/webauthn/#verifying-assertion</li> </ul>"},{"location":"services/login-protocol/#appendix","title":"Appendix","text":""},{"location":"services/login-protocol/#the-fido-protocols-security-goals","title":"The FIDO Protocols: Security Goals","text":""},{"location":"services/login-protocol/#sg-1","title":"[SG-1]","text":"<p>Strong User Authentication: Authenticate (recognize) a user and/or a device to a relying party with high (cryptographic) strength. </p>"},{"location":"services/login-protocol/#sg-2","title":"[SG-2]","text":"<p>Credential Guessing Resilience: Provide robust protection against eavesdroppers, e.g.\u00a0be resilient to physical observation, resilient to targeted impersonation, and resilient to throttled and unthrottled guessing.</p>"},{"location":"services/login-protocol/#sg-3","title":"[SG-3]","text":"<p>Credential Disclosure Resilience: Be resilient to phishing attacks and real-time phishing attacks including resilience to online attacks by adversaries that are able to actively manipulate network traffic. </p>"},{"location":"services/login-protocol/#sg-4","title":"[SG-4]","text":"<p>Unlinkablity: Protect the protocol conversation such that any two relying parties cannot link the conversation to one user (i.e.\u00a0be unlinkable). </p>"},{"location":"services/login-protocol/#sg-5","title":"[SG-5]","text":"<p>Verifier Leak Resilience: Be resilient to leaks from other relying parties,i.e. nothing that the verifier could possibly leak can help an attacker impersonate the user to a relying party. </p>"},{"location":"services/login-protocol/#sg-6","title":"[SG-6]","text":"<p>Authenticator Leak Resilience: Be resilient to leaks from other FIDO Authenticators i.e., nothing that a particular FIDO Authenticator could possibly leak can help an attacker impersonate any other user to a relying party. </p>"},{"location":"services/login-protocol/#sg-7","title":"[SG-7]","text":"<p>User Consent: Notify the user before a relationship with a new relying party is being established (requiring explicit consent). </p>"},{"location":"services/login-protocol/#sg-8","title":"[SG-8]","text":"<p>Limited PII: Limit to the absolute minimum the amount of the Personal Identifiable Information (PII) that can get exposed to the relying party.</p>"},{"location":"services/login-protocol/#sg-9","title":"[SG-9]","text":"<p>Attestable Properties: The relying party must be able to verify FIDO Authenticator model/type (in order to calculate the associated risk). </p>"},{"location":"services/login-protocol/#sg-10","title":"[SG-10]","text":"<p>DoS Resistance: Be resilient to the Denial of Service attacks, i.e. prevent attackers from inserting invalid registration information for a legitimate user for the next login phase and therefore, the legitimate user will not be able to login successfully anymore. </p>"},{"location":"services/login-protocol/#sg-11","title":"[SG-11]","text":"<p>Forgery Resistance: Be resilient to the forgery attacks (impersonation attacks), i.e. prevent attackers from attempting to modify intercepted communications in order to masquerade as the legitimate user and be able to log in to the system. </p>"},{"location":"services/login-protocol/#sg-12","title":"[SG-12]","text":"<p>Parallel Session Resistance: Be resilient to the parallel session attacks. Without knowing a user\u2019s authentication credential, an attacker can masquerade as a legitimate user. This can be done by creating a valid authentication message out of some eavesdropped communication between the user and the server. </p>"},{"location":"services/login-protocol/#sg-13","title":"[SG-13]","text":"<p>Forwarding Resistance: Be resilient to the forwarding and replay attacks. Having intercepted previous communications, an attacker can impersonate the legal user to authenticate to the system. This attacker can replay or forward the intercepted messages. </p>"},{"location":"services/login-protocol/#sg-14","title":"[SG-14]","text":"<p>Transaction Non-Repudiation : Provide strong cryptographic non-repudiation for secure transactions. </p>"},{"location":"services/login-protocol/#sg-15","title":"[SG-15]","text":"<p>Respect for Operating Environment Security Boundaries: Ensure that the registrations and the private keys, as a shared system resource, are appropriately protected according to the operating environment privilege boundaries on the FIDO user device. </p>"},{"location":"services/login-protocol/#sg-16","title":"[SG-16]","text":"<p>Assessable Level of Security: Ensure that the design and implementation of the authenticator allow the testing laboratory/FIDO Alliance to assess the level of security provided by the authenticator.</p>"},{"location":"services/rhs/","title":"Reverse Hash Service","text":""},{"location":"services/rhs/#overview","title":"Overview","text":"<p>The Reverse Hash Service (RHS) is a service that allows users to construct proofs of existence or non-existence of elements in sparse merkle trees without revealing the specific element being proved. This service aims to enhance privacy of credential revocation status checks for identities.</p>"},{"location":"services/rhs/#introduction","title":"Introduction","text":"<p>Identities consist of both private and public data. Public data should be accessible to everyone, while private data should only be available to the identity owner.</p> <p></p> <p>Identity State Diagram for Direct Identity</p> <p>The public data of identity includes:</p> <ul> <li>The identity state, which is stored on the blockchain.</li> <li>Roots of the identity trees: Claims tree(ClT), Revocation tree(ReT), and Roots tree(RoT).</li> <li>All the nodes of the Revocation tree and Roots tree are public.</li> </ul> <p>The Reverse Hash Service stores nodes of SMTs (In our case, the CIT / ReT / RoT and identity state). This service enables users to perform reverse hash lookups and construct proofs of <code>existence</code> or <code>non-existence</code> of elements without revealing the specific element being proved. The main objective of this service is to enhance the privacy and security of iden3 identities while ensuring data integrity.</p>"},{"location":"services/rhs/#non-revocation-proof","title":"Non-revocation proof","text":"<p>To build non-revocation proof, we must prove that revocation nonce is not in the revocation tree.</p> <ol> <li>The first thing we need is to get the <code>latest state</code> of the identity from the State smart contract.</li> <li>Then we can find <code>roots</code> of the trees (Clams tree root, Revocation tree root and Roots Tree root) from RHS.</li> <li>Once we have the <code>roots</code>, we can do a reverse hash lookup to construct merkle tree proof for revocation nonce in Revocation Tree as follows:</li> <li>Start at the root of the tree. Iterate through each level of the tree until reaching a leaf node or exceeding the maximum tree depth.</li> <li>For each level, fetch the corresponding node using the RHS API.</li> <li>Based on the type of node encountered (leaf or middle node), perform different actions:<ul> <li>If the node is a leaf node and its key matches the input key, the proof of existence is complete. Set the <code>exists</code> variable to <code>true</code>, and return the constructed proof.</li> <li>If the node is a leaf node but its key does not match the input key, the <code>proof of non-existence</code> is complete. Set the <code>nodeAux</code> variable with the leaf node\u2019s <code>key</code> and <code>value</code>, and return the constructed proof.</li> <li>If the node is a middle node, determine how to traverse the tree by checking the input key\u2019s corresponding bit at the current depth. Update the next key to traverse and add the sibling node to the siblings list for proof construction.</li> <li>If the algorithm reaches the maximum tree depth without finding a leaf node or a matching key, return an error indicating the tree depth is too high.</li> </ul> </li> </ol> <p><pre><code>sequenceDiagram\n    participant User\n    participant SmartContract as State Smart Contract\n    participant RHS as RHS Storage\n    User-&gt;&gt;SmartContract: Request latest identity state\n    SmartContract-&gt;&gt;User: Return latest identity state\n    User-&gt;&gt;RHS: Fetch roots of trees using identity state\n    RHS-&gt;&gt;User: Return roots of trees  [ClR, ReR, RoR]\n    User-&gt;&gt;RHS: Request children of revocation root(ReR)\n    RHS-&gt;&gt;User: Return [left,right] nodes\n    loop until leaf node is found or max depth is reached\n        User-&gt;&gt;RHS: Request children of node\n        RHS-&gt;&gt;User: Return [left,right] nodes\n    end\n    User-&gt;&gt;User: Calculate Proof</code></pre> By following these steps, the algorithm generates a Merkle proof of existence or non-existence for a given key in a Sparse Merkle Tree without revealing the specific element being proved.</p>"},{"location":"services/rhs/#rhs-storage","title":"RHS Storage","text":"<p>RHS Storage is a persistence layer that stores hashes of preimages. A preimage is an array of integers, which length can be theoretically any number starting from 1. In practice, only support arrays of length 2 and 3 is guaranteed as it is used in the Iden3 protocol.</p> <p>The storage implements key-value approach, where key is a hash of preimage and value is a preimage itself. It is only possible to set a value for a key, but not the key itself as the key is calculated by RHS Storage as a hash of preimage using Poseidon hash function in the transaction that sets the value.</p> <p>RHS Storage can be on-chain or off-chain type.</p> <p>In the case of on-chain storage, the key-value storage is a smart contract with an interface as follows: <pre><code>interface IRHSStorage {\n   /**\n    * @dev Saves nodes array. Note that each node contains an array itself.\n     * @param nodes An array of nodes\n     */\n   function saveNodes(uint256[][] memory nodes) external;\n\n   /**\n    * @dev Returns a node by its key. Note that a node contains an array.\n     * @param key The key of the node\n     * @return The node\n     */\n   function getNode(uint256 key) external view returns (uint256[] memory);\n}\n</code></pre> In the case of off-chain storage, the key-value storage is may be implemented as a service on top of a database. It can be found in the reverse-hash-service repository.</p> <p>The service exposes two endpoints: <pre><code>/POST {{server}}/node\nContent-Type: application/json\n\n{\n   \"hash\":\"2c32381aebce52c0c5c5a1fb92e726f66d977b58a1c8a0c14bb31ef968187325\",\n   \"children\":[\n      \"658c7a65594ebb0815e1cc20f54284ccdb51bb1625f103c116ce58444145381e\",\n      \"e809a4ed2cf98922910e456f1e56862bb958777f5ff0ea6799360113257f220f\"\n   ]\n}\n\n\n/GET {{server}}/node/{{hash}}\n</code></pre></p>"},{"location":"services/rhs/#rhs-client-interface-and-reverse-hash-lookup","title":"RHS Client interface and Reverse Hash Lookup","text":"<p>The RHS Client interface abstracts away the specific RHS Storage implementation. You are free to choose whether to connect your clients directly to RHS Storage or use RHS Client interface.</p> <p>The interface defines three methods: - SaveNodes: saves nodes of the tree to RHS - GetNode: gets node of the tree from RHS, so it does a reverse hash lookup and reveals the preimage of the hash - GenerateProof: generates proof of existence or non-existence of the element in the Sparse Merkle Tree according to the algorithm described below</p> <p>The library that implements the RHS Client interface is located in the merkletree-proof repository and the interface itself is as follows:</p> <pre><code>type ReverseHashCli interface {\n    GenerateProof(ctx context.Context,\n        treeRoot *merkletree.Hash,\n        key *merkletree.Hash) (*merkletree.Proof, error)\n    GetNode(ctx context.Context,\n        hash *merkletree.Hash) (Node, error)\n    SaveNodes(ctx context.Context,\n        nodes []Node) error\n}\n</code></pre> <p>The Node struct is defined as follows: <pre><code>type Node struct {\n    Hash     *merkletree.Hash    // merkletree.Hash is an array of 32 bytes\n    Children []*merkletree.Hash\n}\n</code></pre> Note, that the Hash field of the Node struct is a hash of the Children field, however it is not saved to RHS in the SaveNodes() method as it is calculated by RHS Storage itself. </p>"},{"location":"services/rhs/#publishing-identity-state-to-rhs","title":"Publishing identity state to RHS","text":"<p>If identity holder wants to publish his identity state to RHS he needs to do the following:</p> <ol> <li>Save the state of identity to RHS <code>{ Hash: state, Children: [ClaimsTreeRoot, RevocationTreeRoot, RootsTreeRoot] }</code></li> <li>Save the nodes of Revocation tree and Roots tree to RHS for the intermediate nodes <code>{ Hash: hash, Children: [left, right] }</code> where left and right are the hashes of the children of the node. And for the leaf nodes <code>{ Hash: hash, Children: [key, value, 1] }</code></li> </ol>"},{"location":"services/rhs/#example-with-off-chain-rhs-storage","title":"Example with off-chain RHS storage:","text":"<pre><code>package main\n\nimport (\n    \"context\"\n    \"encoding/json\"\n    \"fmt\"\n    \"math/big\"\n\n    \"github.com/iden3/go-merkletree-sql/v2\"\n    proof \"github.com/iden3/merkletree-proof/http\"\n)\n\nfunc main() {\n    ctx := context.Background()\n    rhsURL := \"https://rhs-staging.polygonid.me\"\n    state := \"e12084d0d72c492c703a2053b371026bceda40afb9089c325652dfd2e5e11223\"\n    revocationNonce, _ := merkletree.NewHashFromBigInt(big.NewInt(670966937))\n\n    cli := &amp;proof.ReverseHashCli{URL: rhsURL}\n\n    // get identity state roots (ClT root, ReT root, RoT root)\n    node := getIdentityStateRoots(cli, ctx, state)\n    json, err := json.Marshal(node)\n    if err != nil {\n        panic(err)\n    }\n    fmt.Println(string(json))\n\n    // get non-revocation proof by ReT root and revocation nonce\n    proof, err := cli.GenerateProof(ctx, node.Children[1], revocationNonce)\n    if err != nil {\n        panic(err)\n    }\n    jsonProof, err := proof.MarshalJSON()\n    if err != nil {\n        panic(err)\n    }\n\n    fmt.Println(string(jsonProof))\n}\n\nfunc getIdentityStateRoots(cli *proof.HTTPReverseHashCli, ctx context.Context, state string) proof.Node {\n    s, err := merkletree.NewHashFromHex(state)\n    if err != nil {\n        panic(err)\n    }\n\n    stateValues, err := cli.GetNode(ctx, s)\n    if err != nil {\n        panic(err)\n    }\n\n    return stateValues\n}\n</code></pre> <p>!!! Note that on-chain RHS storage initialization is a bit more complex. Check merkletree-proof library for more details.</p>"},{"location":"services/rhs/#rhs-storage-implementation","title":"RHS Storage Implementation","text":"<p>Off-chain: https://github.com/iden3/reverse-hash-service</p> <p>On-chain: https://github.com/iden3/contracts/blob/master/contracts/identitytreestore/IdentityTreeStore.sol</p> <p>!!! Note that IdentityTreeStore implements SMT Proof generation algorithm on-chain as part of getRevocationStatusByIdAndState() method, so you are free to use it as alternative way to generate revocation proofs. </p>"},{"location":"services/rhs/#library-to-interact-with-rhs-storage","title":"Library to interact with RHS Storage","text":"<p>https://github.com/iden3/merkletree-proof</p>"},{"location":"services/rhs/#links","title":"Links","text":"<p>https://docs.iden3.io/publications/pdfs/Merkle-Tree.pdf</p> <p>https://github.com/iden3/go-merkletree-sql</p> <p>https://github.com/0xPolygonID/js-sdk</p>"},{"location":"w3c/merklization/","title":"JSON-LD document merklization","text":""},{"location":"w3c/merklization/#motivation","title":"Motivation","text":"<p>Implement a data structure that allows generating zero-knowledge proofs based on individual entries of JSON-LD documents. This will enable users to prove certain statements about their data without revealing the actual content, thereby preserving privacy and ensuring data security..</p>"},{"location":"w3c/merklization/#core-concept","title":"Core Concept","text":"<p>Convert a JSON-LD document into a Merkle Tree data structure (namely, merklize it), and prove the inclusion of the entries in the tree.</p> <p>To achieve this, take the JSON-LD document and convert it to an expanded form. Then, normalize it using the URDNA2015 algorithm,  which results in a list of RDF Quads. For each Quad, construct key-value pairs and add them to the Merkle Tree.</p> <pre><code>map[path]value\n</code></pre> <p>Example</p> <pre><code>map[https://www.w3.org/2018/credentials#expirationDate] = 1890994792000000000\n</code></pre> <p>For example</p> <pre><code>{  \"@context\": \"http://schema.org/\",  \"@type\": \"Person\",  \"name\": \"Jane Doe\",  \"jobTitle\": \"Professor\",  \"telephone\": \"(425) 123-4567\",}\n</code></pre> <p>Can be presented as</p> Path Value http://schema.org/jobTitle Professor http://schema.org/name Jane Doe http://schema.org/telephone (425) 123-4567 http://www.w3.org/1999/02/22-rdf-syntax-ns#type http://schema.org/Person <p>The data included in the map can be stored in a Sparse Merkle tree where:</p> <ul> <li>the <code>index</code> of an entry in the tree is its path</li> <li>the <code>value</code> of an entry in the tree is the hash of its value</li> </ul> <p></p>"},{"location":"w3c/merklization/#merklization-algorithm","title":"Merklization Algorithm","text":"<p>Before splitting a JSON-LD document into tree entries, it must be converted into an expanded format and normalized using  the URDNA2015 algorithm. Normalization is required to ensure a predictable order of array elements when multiple child  elements exist under the same parent with the same predicate. Most JSON-LD documents use a compact format that employs  shorthand terms to represent commonly used IRIs (Internationalized Resource Identifiers). In contrast, the expanded format uses full IRIs.</p> <p>This process dereferences all terms into fully-qualified IRI values, making it easier to work with the data in a  standardized and predictable manner.</p> <p>Example:</p> <p>JSON-LD document compact format:</p> <pre><code>{    \n\"@context\": [\n        \"http://schema.org/\",        \n                \"https://w3id.org/citizenship/v1\",        \n                \"https://www.w3.org/2018/credentials/v1\"],    \n\"@type\": \"Person\",    \n\"name\": \"Jane Doe\",    \n\"jobTitle\": \"Professor\",    \n\"credentialSubject\": {        \n                \"@type\": \"PermanentResident\",        \n                \"birthCountry\": \"Spain\"    }\n}\n</code></pre> <p>Expanded format:</p> <pre><code>[\n  {\n    \"@type\": [\n      \"http://schema.org/Person\"\n    ],\n    \"http://schema.org/credentialSubject\": [\n      {\n        \"@type\": [\n          \"https://w3id.org/citizenship#PermanentResident\"\n        ],\n        \"https://w3id.org/citizenship#birthCountry\": [\n          {\n            \"@value\": \"Spain\"\n          }\n        ]\n      }\n    ],\n    \"http://schema.org/jobTitle\": [\n      {\n        \"@value\": \"Professor\"\n      }\n    ],\n    \"http://schema.org/name\": [\n      {\n        \"@value\": \"Jane Doe\"\n      }\n    ]\n  }\n]\n</code></pre> <p>Starting from the expanded format, it is possible to build path-value entries for each entry of the JSON-LD Document to be stored inside the Merkle Tree.</p> <p>If there is an array of objects, we use integers as an index in the path. For example, if we have an array of <code>PermanentResident</code> objects in <code>credentialSubject</code> field, then the path will look like <code>[\"http://schema.org/credentialSubject\", 0, \u201chttps://w3id.org/citizenship#birthCountry\u201d]</code></p> <p>To store an entry of the JSON-LD Document into a Merkle tree, we need to calculate hashes (of integer type) for the path and the value. The hashing interface has to have three methods:</p> <ul> <li>Method #1: Return the Int value of hash from an array of other Ints</li> </ul> <pre><code>// PSEUDOCODE\nfunction hashInts (arr : int[]) :int\n</code></pre> <ul> <li>Method #2: Return the Int value of hash from an arbitrary array of bytes. Poseidon uses sponge hashing. Split input byte array in 31-byte blocks. And hash in chunks of 16 blocks (the first element of the next 16-block chink is a hash of the previous chunk)</li> </ul> <pre><code>// PSEUDOCODE\nfunction hashBytes (arr : bytes[]) :int\n</code></pre> <ul> <li>Method #3: Return the Prime of the field used. For Poseidon hashing, it equals <code>21888242871839275222246405745257275088548364400416034343698204186575808495617</code></li> </ul> <pre><code>// PSEUDOCODE\nfunction prime () :int\n</code></pre> <p>To calculate the hash of the path, we replace all string elements of the path with hashes of those strings using method #2. All strings are interpreted as bytes array of UTF-8 representation of the string. Int index values are left as is in the path. In the end, we hash an array of Integers using method #1.</p> <pre><code>// PSEUDOCODE\nfunction hashPath (path : (string | int)[]) :int {\n\n    for (let i = 0; i &lt; path.length; i++) {\n\n                if (typeof path[i] == string {\n                        let utf8Bytes = encode(path[i]);\n                        path[i] = hashBytes(utf8Bytes)\n                }\n\n    }\n\n    return hashInts(path)\n}\n</code></pre> <p>To calculate the hash of the value, use different methods depending on the value type.</p> <ul> <li>For positive integers, we use the value as is.</li> <li>The negative integer <code>N</code> is represented as <code>prime() - abs(N)</code></li> <li>For boolean values, hash equals 0 for false and 1 for true.</li> <li>For string values we use method #2 to hash byte array of UTF-8 representation of string</li> <li>For DateTime the hash value is a Unix timestamp in nano-seconds.</li> </ul> <pre><code>// PSEUDOCODE\nfunction hashValue (value : (int | bool | string | DateTime) :int {\n\n    if (typeof value == bool) {\n        value ? return hashInts([1]) : return hashInts([0])\n    }\n\n    if (typeof value == int) {\n    if (value &lt; 0) {\n            value = prime() - abs(value)\n        }\n        return hashInts([value])\n    }\n\n    if (typeof value == string) {\n        const utf8Bytes = encode(value);\n        return hashBytes(utf8Bytes)\n    }\n\n  if(typeof value == DateTime) {\n        return value.UnixTimestampNano()\n  }\n}\n</code></pre> <p>Given hash values for Path and Value, both in integer format, we put them into the Sparse Merkle Tree.</p>"},{"location":"w3c/merklization/#normalization-example","title":"Normalization example","text":"<p>There are two cases we need to handle carefully during the normalization of the JSON-LD document</p> <ul> <li>Multigraph document</li> <li>Swapping array elements</li> </ul> <p>In the following document, the type of <code>verifiableCredential</code> is declared as <code>\"@container\": \"@graph\"</code> in the schema. In this case, we need to link those graphs correctly while building path keys.</p> <p>Also, during normalization, the object with the identifier <code>[http://example.com/vc3](http://example.com/vc3)</code> goes before the object with the identifier <code>http://example.com/vc1</code>. So it gets index 0, and <code>vc1</code> gets index 1. This is because during canonization, the name of the graph with id <code>http://example.com/vc3</code> is :c14n1 and the name of the graph with id <code>http://example.com/vc1</code> is :c14n2. When building indexing, embedded graphs are sorted in lexical order, so <code>http://example.com/vc3</code> comes before <code>http://example.com/vc1</code>.</p> <p>Example document:</p> <pre><code>{\n  \"@context\":[\n    \"https://www.w3.org/2018/credentials/v1\",\n    \"https://raw.githubusercontent.com/iden3/claim-schema-vocab/main/schemas/json-ld/kyc-v3.json-ld\",\n    \"https://raw.githubusercontent.com/iden3/claim-schema-vocab/main/schemas/json-ld/iden3credential-v2.json-ld\"\n  ],\n  \"@type\":\"VerifiablePresentation\",\n  \"verifiableCredential\":[\n    {\n      \"@id\": \"http://example.com/vc1\",\n      \"@type\":\"KYCAgeCredential\",\n      \"birthday\":19960424\n    },\n    {\n      \"@id\": \"http://example.com/vc3\",\n      \"@type\": \"Iden3SparseMerkleTreeProof\",\n      \"issuerData\": {\n        \"state\": {\n          \"blockTimestamp\": 123\n        }\n      }\n    }\n  ]\n}\n</code></pre> <p>After normalization nodes under <code>verifiableCredential</code> will be swapped, and the path to <code>blockTimestamp</code> would look like</p> <pre><code>[\n    \"https://www.w3.org/2018/credentials#verifiableCredential\",\n    0,\n    \"https://github.com/iden3/claim-schema-vocab/blob/main/proofs/Iden3SparseMerkleTreeProof-v2.md#issuerData\",\n    \"https://github.com/iden3/claim-schema-vocab/blob/main/proofs/Iden3SparseMerkleTreeProof-v2.md#state\",\n    \"https://github.com/iden3/claim-schema-vocab/blob/main/proofs/Iden3SparseMerkleTreeProof-v2.md#blockTimestamp\"\n]\n</code></pre> <p>And the path to <code>birthday</code> is</p> <pre><code>[\n    \"https://www.w3.org/2018/credentials#verifiableCredential\",\n    1,\n    \"https://github.com/iden3/claim-schema-vocab/blob/main/credentials/kyc.md#birthday\"\n]\n</code></pre>"},{"location":"w3c/merklization/#proof-of-inclusion-and-non-inclusion","title":"Proof of Inclusion and Non-Inclusion","text":"<p>Each entry of the JSON-LD document can now be added inside the Sparse Merkle Tree. For example, the entry <code>(birthCountry-&gt;Spain)</code> can be express as</p> <pre><code>map[\"http://schema.org/credentialSubject\", \"https://w3id.org/citizenship#birthCountry\"] = \"Spain\"\n</code></pre> <p>After having performed the hashing to <code>path</code> and <code>value</code> as described in the algorithm section and adding it to the Sparse Merkle Tree, it is possible to generate <code>proof of inclusion</code> of the element inside the tree. The implementation of that will be described in the next paragraph.</p> <p>Sparse Merkle Tree also allows to generate <code>proof of non-inclusion</code> of entries inside the JSON-LD document. For example, we can prove that an entry with a field  <code>name</code> is not included in the document by starting from its path.</p> <pre><code>[\"http://schema.org/credentialSubject\", \u201chttps://w3id.org/citizenship#name\u201d]\n</code></pre>"},{"location":"w3c/merklization/#implementation-merklize","title":"Implementation - Merklize","text":"<p>The following code snippet describes how to use the go schema processor Library to merklize a JSON-LD document. Starting from the merklized version of the JSON-LD it is possible to generate proof of inclusion (or of non-inclusion) of entries starting from their <code>path</code></p> <p>This implementation makes use of <code>[poseidonHash](https://www.poseidon-hash.info)</code> as hashing algorithm inside the tree.</p> <pre><code>package main\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"strings\"\n    \"github.com/iden3/go-schema-processor/merklize\"\n)\n\nfunc main() {\n\n  // Start from a standard JSON-LD Document\n    const doc = `{\n    \"@context\": [\n        \"http://schema.org/\",\n        \"https://w3id.org/citizenship/v1\",\n        \"https://www.w3.org/2018/credentials/v1\"\n    ],\n    \"@type\": \"Person\",\n    \"name\": \"Jane Doe\",\n    \"jobTitle\": \"Professor\",\n    \"credentialSubject\": {\n        \"@type\": \"PermanentResident\",\n        \"birthCountry\": \"Spain\"\n    }\n}`\n\n  // Merklize the JSON-LD Document\n    mz, err := merklize.MerklizeJSONLD(context.Background(), strings.NewReader(doc))\n    if err != nil {\n        panic(err)\n    }\n\n  // Print the root of the newly generated Sparse Merkle Tree \n    fmt.Println(\"Root:\", mz.Root().Hex())\n\n  // Now let's generate a proof of inclusion for a specific path\n\n  // Parse the path \n    path, err := merklize.NewPath(\"http://schema.org/credentialSubject\", \"https://w3id.org/citizenship#birthCountry\")\n    if err != nil {\n        panic(err)\n    }\n\n  // Generate the proof of inclusion for an entry corresponding to that path\n    proof, value, err := mz.Proof(context.Background(), path)\n    if err != nil {\n        panic(err)\n    }\n\n    // Print the proof\n    fmt.Println(\"Proof:\", proof)\n    fmt.Println(\"Existence:\", proof.Existence)\n    fmt.Println(\"Siblings:\", proof.AllSiblings())\n    fmt.Println(\"Aux:\", proof.NodeAux)\n\n    // Print the value inside the SMT associated with that path\n    fmt.Println(\"Value:\", value)\n\n}\n</code></pre>"},{"location":"w3c/merklization/#implementation-zk-prover","title":"Implementation - ZK Prover","text":"<p>The following provides an example of a general-purpose zk circuit, written in circom, that proves inclusion of an element inside a Sparse Merkle Tree. This implementation can be adapted to prove inclusion of an entry inside a JSON-LD Document starting from its path.</p> <pre><code>template MTVerifier() {\n    signal input root;\n\n    // expiration time\n    signal input expirationDate; // timestamp\n    signal input expirationValue;\n    signal input expirationMtp[32];\n\n    // expiration date\n    // https://www.w3.org/2018/credentials#expirationDate\n    // https://www.w3.org/2018/credentials#expirationDate &lt; expirationDate\n    component expirationInMT = SMTVerifier(32);\n    expirationInMT.enabled &lt;== 1;\n    expirationInMT.fnc &lt;== 0; // inclusion\n    expirationInMT.root &lt;== root;\n    for (var i=0; i&lt;32; i++) { expirationInMT.siblings[i] &lt;== expirationMtp[i]; }\n    expirationInMT.oldKey &lt;== 0;\n    expirationInMT.oldValue &lt;== 0;\n    expirationInMT.isOld0 &lt;== 0;\n    expirationInMT.key &lt;== 13483382060079230067188057675928039600565406666878111320562435194759310415773;\n    expirationInMT.value &lt;== expirationValue;\n}\n</code></pre> <p>Base verifications can be extended with any combination of fields, although some verification can be required by specific circuits. For example, verification of expiration time can be required without reviling expiration time to the verifier. Verifier will know only that the expiration time is greater than the current time.</p>"},{"location":"w3c/merklization/#conclusion","title":"Conclusion","text":"<p>The proposed approach enables to generate ZK proofs based over Verifiable Credentials (VC), which are formatted into JSON-LD data format. This open ups new possibilities:</p> <ul> <li>Do selective disclosure over entries of a VC. Namely, a user can disclose a single entry inside a proof without revealing any other entry of the document</li> <li>Do query request over entries of a VC. Namely, a user can prove that an entry satisfies a certain query without revealing the value of the entry itself (and any other entry of the document)</li> <li>Prove non membership of an entry with a specific path. Namely, a user can prove that an entry with a specific path doesn\u2019t exist inside a VC.</li> <li>Prove non membership of a entry with a specific path and value. Namely, a user can prove that an entry with a specific path and value doesn\u2019t exist inside a VC.</li> <li>The proof can be verified inside smart contract making VC compatible with on-chain interactions.</li> </ul>"},{"location":"w3c/merklization/#implementations","title":"Implementations","text":"<p>Implementation of the proposed approach is available in the following repositories:</p> <ul> <li>Go - https://github.com/iden3/go-schema-processor</li> <li>JS - https://github.com/iden3/js-jsonld-merklization</li> </ul>"}]}